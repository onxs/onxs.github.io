<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.2.0">
<link rel="preconnect" href="https://fonts.loli.net" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#000000">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=PingFang+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-loading-bar.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"onxs.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":true,"sidebar":{"position":"left","width_expanded":250,"width_dual_column":250,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"buttons","active":null,"storage":false,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/config.min.js"></script>



<link rel="canonical" href="https://onxs.github.io/post/2018021344.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://onxs.github.io/post/2018021344.html","path":"post/2018021344.html","title":"Java成神之路-JavaSE 面向对象和Java常用类（五）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java成神之路-JavaSE 面向对象和Java常用类（五） | NesT</title>
  









  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="NesT" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NesT</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">MC Personal Nest</p>
      <img class="custom-logo-image" src="https://s2.loli.net/2024/05/04/oabunWyc5VspNeU.png" alt="NesT">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">72</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">59</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">175</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>


</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E7%AE%80%E4%BB%8B"><span class="nav-text">java简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-java%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.java是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JVM"><span class="nav-text">2.JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">3.java程序运行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-java%E7%89%88%E6%9C%AC"><span class="nav-text">4.java版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-JDK"><span class="nav-text">5.JDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JRE"><span class="nav-text">6.JRE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-API"><span class="nav-text">7.API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-java%E7%89%B9%E6%80%A7"><span class="nav-text">8.java特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#window%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85java"><span class="nav-text">window系统安装java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BDJDK"><span class="nav-text">下载JDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">配置环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA-HOME-%E8%AE%BE%E7%BD%AE"><span class="nav-text">JAVA_HOME 设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PATH%E8%AE%BE%E7%BD%AE"><span class="nav-text">PATH设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLASSPATH-%E8%AE%BE%E7%BD%AE"><span class="nav-text">CLASSPATH 设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95JDK%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="nav-text">测试JDK是否安装成功</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%EF%BC%8CUNIX%EF%BC%8CSolaris%EF%BC%8CFreeBSD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE"><span class="nav-text">Linux，UNIX，Solaris，FreeBSD环境变量设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E8%A1%8CJAVA%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-text">流行JAVA开发工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Eclipse-%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA-Java-%E7%A8%8B%E5%BA%8F"><span class="nav-text">使用 Eclipse 运行第一个 Java 程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0"><span class="nav-text">Java基本语言元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E5%88%99"><span class="nav-text">规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%9B%9B%E7%B1%BB%E5%85%AB%E7%A7%8D%EF%BC%89"><span class="nav-text">基本数据类型（四类八种）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F"><span class="nav-text">变量、常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-text">字符串类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">Java流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0"><span class="nav-text">笔记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%95%B0%E7%BB%84"><span class="nav-text">Java 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F"><span class="nav-text">声明数组变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="nav-text">处理数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#foreach-%E5%BE%AA%E7%8E%AF"><span class="nav-text">foreach 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">数组作为函数的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">数组作为函数的返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-text">多维数组的动态初始化（以二维数组为例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-text">多维数组的引用（以二维数组为例）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays-%E7%B1%BB"><span class="nav-text">Arrays 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8"><span class="nav-text">笔记列表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="nav-text">Java面向对象基础知识总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8FVS%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">成员变量VS局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">匿名对象：没有定义名称的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">静态变量和成员变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">抽象类和抽象方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Object%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">Java常用类——Object的通用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#equlas%E5%92%8ChashCode%E6%96%B9%E6%B3%95"><span class="nav-text">equlas和hashCode方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString%E6%96%B9%E6%B3%95"><span class="nav-text">toString方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone%E6%96%B9%E6%B3%95"><span class="nav-text">clone方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals%E6%96%B9%E6%B3%95%E4%B8%8E%E2%80%9D-%E2%80%9D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">equals方法与”&#x3D;&#x3D;”操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84%E5%B8%AE%E5%8A%A9%E7%B1%BB"><span class="nav-text">有用的帮助类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-API-%E2%80%94%E2%80%94StringBuffer%E7%B1%BB"><span class="nav-text">Java API ——StringBuffer类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="nav-text">StringBuffer类概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">StringBuffer类的成员方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="nav-text">添加功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="nav-text">删除功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%8A%9F%E8%83%BD"><span class="nav-text">替换功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%8A%9F%E8%83%BD"><span class="nav-text">反转功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%AA%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="nav-text">截取功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E4%B8%8EStringBuffer%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="nav-text">String与StringBuffer的相互转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">把数组拼接成一个字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="nav-text">把字符串反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84"><span class="nav-text">判断一个字符串是否是对称的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BStringBuilder%E7%B1%BB"><span class="nav-text">了解一下StringBuilder类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">String,StringBuffer,StringBuilder的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E7%B1%BB"><span class="nav-text">Java 常用类——String类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">String类对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">String类构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">String类常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">字符串与基本类型的转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%B1%BB%E2%80%94%E2%80%94Math%E7%B1%BB"><span class="nav-text">Java类——Math类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-math-Math%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B8%B8%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text">java.math.Math类常用的常量和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%9A%84Math%E7%B1%BB%E5%B0%81%E8%A3%85%E4%BA%86%E5%BE%88%E5%A4%9A%E4%B8%8E%E6%95%B0%E5%AD%A6%E6%9C%89%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E5%A4%A7%E8%87%B4%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-text">Java的Math类封装了很多与数学有关的属性和方法，大致如下：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%ADDate%E5%90%84%E7%A7%8D%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95"><span class="nav-text">Java中Date各种相关用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%80%E6%9C%88%E4%BB%BD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A4%A9%E6%95%B0"><span class="nav-text">计算某一月份的最大天数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Calendar%E5%92%8CDate%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="nav-text">Calendar和Date的转化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-text">格式化输出日期时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E6%98%9F%E6%9C%9F"><span class="nav-text">计算一年中的第几星期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#add-%E5%92%8Croll-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">add()和roll()的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E4%B8%AD%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%94%E5%A4%A9%E6%95%B0"><span class="nav-text">计算两个任意时间中间的间隔天数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4"><span class="nav-text">获取系统当前时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%AADate%EF%BC%88java-sql-Date%EF%BC%89"><span class="nav-text">将字符串类型的日期转换为一个Date（java.sql.Date）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cyrus"
      src="https://s2.loli.net/2024/05/04/r4KT1NyzbACneI7.gif">
  <p class="site-author-name" itemprop="name">Cyrus</p>
  <div class="site-description" itemprop="description">Keep quiet time for time.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">175</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ueHM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;onxs"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmNlZWtAdmlwLnFxLmNvbQ==" title="E-Mail → mailto:ceek@vip.qq.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS8=" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;"><i class="fab fa-twitter fa-fw"></i></span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>


        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://onxs.github.io/post/2018021344.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s2.loli.net/2024/05/04/r4KT1NyzbACneI7.gif">
      <meta itemprop="name" content="Cyrus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NesT">
      <meta itemprop="description" content="Keep quiet time for time.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java成神之路-JavaSE 面向对象和Java常用类（五） | NesT">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java成神之路-JavaSE 面向对象和Java常用类（五）<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ueHMvYmxvZy90cmVlL2Rldi9zb3VyY2UvX3Bvc3RzL0phdmHmiJDnpZ7kuYvot68tSmF2YVNFIOmdouWQkeWvueixoeWSjEphdmHluLjnlKjnsbvvvIjkupTvvIkubWQ=" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-23 13:44:36" itemprop="dateCreated datePublished" datetime="2018-02-23T13:44:36+08:00">2018-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  

    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:25</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img data-src="https://s2.loli.net/2023/04/16/XDgYZ2RMLxIl7Vd.jpg"></p>
<p>Java成神之路-面向对象和Java常用类</p>
<span id="more"></span>
<h1 id="java简介"><a href="#java简介" class="headerlink" title="java简介"></a>java简介</h1><h2 id="1-java是什么？"><a href="#1-java是什么？" class="headerlink" title="1.java是什么？"></a>1.java是什么？</h2><p>java是一种高级的面向对象的程序设计语言 。</p>
<h2 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2.JVM"></a>2.JVM</h2><p>Java Virtual Machine，是java程序跨平台的关键，不同的平台有不同的JVM，而java字节码不包含任何与平台相关的信息，不直接与平台交互，而是通过JVM间接与平台交互。应用程序在执行时，JVM加载字节码，将字节码解释成特定平台的机器码，让平台执行。</p>
<p>任何一个应用程序都必须转化为机器码，才能与计算机进行交互，如果机器码的来源依赖于具体的平台，那么这个应用程序就不能跨平台。而java应用程序运行时机器码由java体系的一部分JVM提供，不受平台的限制，所以实现了跨平台。</p>
<h2 id="3-java程序运行过程"><a href="#3-java程序运行过程" class="headerlink" title="3.java程序运行过程"></a>3.java程序运行过程</h2><p>程序员编写的源码经编译器编译转化为字节码，字节码被加载到JVM，由JVM解释成机器码在计算机上运行。</p>
<h2 id="4-java版本"><a href="#4-java版本" class="headerlink" title="4.java版本"></a>4.java版本</h2><p>针对不同的用途，java分为3个版本：</p>
<ol>
<li>Java SE：java的标准版，是其他版本的基础，主要用于开发桌面应用程序。</li>
<li>Java EE：java的企业版，主要用于开发企业级分布式网络程序。</li>
<li>Java ME：主要用于嵌入式系统开发。</li>
</ol>
<h2 id="5-JDK"><a href="#5-JDK" class="headerlink" title="5.JDK"></a>5.JDK</h2><p>Java Develop Kits，使用java语言开发应用程序必备的工具包，主要包含包括了编译器、JVM、Java基础API等。</p>
<h2 id="6-JRE"><a href="#6-JRE" class="headerlink" title="6.JRE"></a>6.JRE</h2><p>Java Run Environment，java运行所依赖的环境，包括JVM以及java基础API。</p>
<h2 id="7-API"><a href="#7-API" class="headerlink" title="7.API"></a>7.API</h2><p>Application Programming Interface，应用程序编程接口，是使用java语言编写应用程序的入口，包含源码、字节码帮助文档三部分。应用程序由一系列方法构成，方法有哪些要求？什么样的方法是编程语言接受的？API提供了一些基础的方法，程序员要实现某项功能必须遵循java语言规范，调用这些方法编写更高级的方法。</p>
<h2 id="8-java特性"><a href="#8-java特性" class="headerlink" title="8.java特性"></a>8.java特性</h2><ol>
<li>简单：java语言是从C++发展起来的，取消了C++中复杂难以掌握的部分，如指针。</li>
<li>面向对象：java语言的基础。java将一切问题都看做对象与对象之间的交互，将对象抽象成方法与属性的集合。</li>
<li>分布性：包含操作分布性与数据分布性两个方面。操作分布性是指由多个主机共同完成一项功能，数据分布性是分布在多台主机上的数据当做一个完成的整体处理。</li>
<li>跨平台：java语言编写的应用程序，不受平台限制，可以由一种平台迁移到另一种平台。</li>
<li>解释型：使用java语言编写的源码被转化为字节码，字节码只有被JVM解释成机器码才能被计算机执行。</li>
<li>安全性：java语言的底层设计可以有效避免非法操作。</li>
<li>健壮性：java提供了许多机制防止运行时出现严重错误，如编译时类型检查、异常处理。</li>
<li>多线程：java支持多线程，允许进程内部多个线程同时工作。</li>
</ol>
<h1 id="window系统安装java"><a href="#window系统安装java" class="headerlink" title="window系统安装java"></a>window系统安装java</h1><h2 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h2><p>首先我们需要下载java开发工具包JDK，下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy5vcmFjbGUuY29tL3RlY2huZXR3b3JrL2phdmEvamF2YXNlL2Rvd25sb2Fkcy9pbmRleC5odG1s">http://www.oracle.com/technetwork/java/javase/downloads/index.html<i class="fa fa-external-link-alt"></i></span>，</p>
<p>下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。</p>
<p>安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 <strong>C:\Program Files (x86)\Java\jdk1.8.0_91</strong>。</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>1.安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；</p>
<p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/win-java1.png" alt="img"></p>
<p>2.选择”高级”选项卡，点击”环境变量”；</p>
<p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win2.png" alt="img"></p>
<p>然后就会出现如下图所示的画面：</p>
<p>在”系统变量”中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。</p>
<p>变量设置参数如下：</p>
<ul>
<li><p>变量名：<strong>JAVA_HOME</strong></p>
</li>
<li><p>变量值：<strong>C:\Program Files (x86)\Java\jdk1.8.0_91</strong>        &#x2F;&#x2F; 要根据自己的实际路径配置</p>
</li>
<li><p>变量名：<strong>CLASSPATH</strong></p>
</li>
<li><p>变量值：**.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;**         &#x2F;&#x2F;记得前面有个”.”</p>
</li>
<li><p>变量名：<strong>Path</strong></p>
</li>
<li><p>变量值：**%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;**</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong>在 Windows10 中，因为系统的限制，path 变量只可以使用 JDK 的绝对路径。%JAVA_HOME% 会无法识别，导致配置失败。如下所示：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">C</span>:\Program Files (x86)\Java\jdk1.<span class="number">8</span>.<span class="number">0</span>_91\bin;C:\Program Files (x86)\Java\jdk1.<span class="number">8</span>.<span class="number">0</span>_91\jre\bin;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="JAVA-HOME-设置"><a href="#JAVA-HOME-设置" class="headerlink" title="JAVA_HOME 设置"></a>JAVA_HOME 设置</h3><p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win4.png" alt="img"></p>
<p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win5.png" alt="img"></p>
<h3 id="PATH设置"><a href="#PATH设置" class="headerlink" title="PATH设置"></a>PATH设置</h3><p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win6.png" alt="img"></p>
<p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win7.png" alt="img"></p>
<h3 id="CLASSPATH-设置"><a href="#CLASSPATH-设置" class="headerlink" title="CLASSPATH 设置"></a>CLASSPATH 设置</h3><p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win8.png" alt="img"></p>
<p>这是 Java 的环境配置，配置完成后，你可以启动 Eclipse 来编写代码，它会自动完成java环境的配置。</p>
<blockquote>
<p><strong>注意：</strong>如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。</p>
</blockquote>
<h3 id="测试JDK是否安装成功"><a href="#测试JDK是否安装成功" class="headerlink" title="测试JDK是否安装成功"></a>测试JDK是否安装成功</h3><p>1、”开始”-&gt;”运行”，键入”cmd”；</p>
<p>2、键入命令: <strong>java -version</strong>、<strong>java</strong>、<strong>javac</strong> 几个命令，出现以下信息，说明环境变量配置成功；</p>
<p><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/java-win9.png" alt="img"></p>
<hr>
<h2 id="Linux，UNIX，Solaris，FreeBSD环境变量设置"><a href="#Linux，UNIX，Solaris，FreeBSD环境变量设置" class="headerlink" title="Linux，UNIX，Solaris，FreeBSD环境变量设置"></a>Linux，UNIX，Solaris，FreeBSD环境变量设置</h2><p>环境变量PATH应该设定为指向Java二进制文件安装的位置。如果设置遇到困难，请参考shell文档。</p>
<p>例如，假设你使用bash作为shell，你可以把下面的内容添加到你的 .bashrc文件结尾: export PATH&#x3D;&#x2F;path&#x2F;to&#x2F;java:$PATH</p>
<hr>
<h2 id="流行JAVA开发工具"><a href="#流行JAVA开发工具" class="headerlink" title="流行JAVA开发工具"></a>流行JAVA开发工具</h2><p>正所谓工欲善其事必先利其器，我们在开发java语言过程中同样需要依款不错的开发工具，目前市场上的IDE很多，本文为大家推荐以下下几款java开发工具：</p>
<ul>
<li><p>**Eclipse（推荐）:**另一个免费开源的java IDE，下载地址： <span class="exturl" data-url="aHR0cDovL3d3dy5lY2xpcHNlLm9yZy8=">http://www.eclipse.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>选择 <strong>Eclipse IDE for Java Developers</strong>：<br><img data-src="http://www.runoob.com/wp-content/uploads/2013/12/5A92DEAE-EFB9-493D-AC4D-808E529B533C.jpg" alt="img"></p>
</li>
<li><p>**Notepad++ : **Notepad++ 是在微软视窗环境之下的一个免费的代码编辑器，下载地址：<span class="exturl" data-url="aHR0cDovL25vdGVwYWQtcGx1cy1wbHVzLm9yZy8="> http://notepad-plus-plus.org/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>**Netbeans:**开源免费的java IDE，下载地址： <span class="exturl" data-url="aHR0cDovL3d3dy5uZXRiZWFucy5vcmcvaW5kZXguaHRtbA==">http://www.netbeans.org/index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<hr>
<h2 id="使用-Eclipse-运行第一个-Java-程序"><a href="#使用-Eclipse-运行第一个-Java-程序" class="headerlink" title="使用 Eclipse 运行第一个 Java 程序"></a>使用 Eclipse 运行第一个 Java 程序</h2><p>演示如下所示：</p>
<p>HelloWorld.java 文件代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;        </span><br><span class="line">	System.out.println(<span class="string">&quot;Hello World&quot;</span>);    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java基本语言元素"><a href="#Java基本语言元素" class="headerlink" title="Java基本语言元素"></a>Java基本语言元素</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol>
<li>命名规则</li>
</ol>
<ul>
<li>类名称：首字母大写，尽可能采取驼峰式命名:MaLin HelloWorld </li>
<li>命名标识符规范：数字、字母、下划线、$组成，但是不能以数字开头，不能是关键字或者保留字。</li>
<li>变量名称 ：首字母必须小写          常量：必须全大些 PI MAX </li>
<li>方法名称：首字母必须小写</li>
</ul>
<ol start="2">
<li>严格区分大小写 </li>
<li>以分号 ‘;’ 结束</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型（四类八种）"><a href="#基本数据类型（四类八种）" class="headerlink" title="基本数据类型（四类八种）"></a>基本数据类型（四类八种）</h3><ol>
<li><strong>简单类型</strong></li>
</ol>
<ul>
<li>第一类：整型 byte short int long</li>
<li>第二类：浮点型 float double</li>
<li>第三类：逻辑型 boolean(它只有两个值可取true false)</li>
<li>第四类：字符型 char</li>
</ul>
<ol start="2">
<li><strong>封装类型</strong>（数据类型转换简单类型）</li>
</ol>
<p><code>Byte Short Integer Long Float Double Character Boolean</code> </p>
<ul>
<li>基本类型只能按值传递，而每个基本类型对应的封装类是按引用传递的。 </li>
<li>从性能上说java中的基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的，（对象的引用在堆栈上创建）</li>
</ul>
<ol start="3">
<li>引用类型</li>
</ol>
<p>数组、 类（对象）、接口</p>
<p>说明： </p>
<p>​       导包快捷键 ctrl+shift+o</p>
<h2 id="变量、常量"><a href="#变量、常量" class="headerlink" title="变量、常量"></a>变量、常量</h2><p><strong>1. 语法</strong>：<br>数据类型 变量名称 [&#x3D; 值];</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> sex; <span class="comment">//声明变量</span></span><br><span class="line">        sex = <span class="string">&#x27;男&#x27;</span>;<span class="comment">//初始化、赋值 </span></span><br><span class="line">        <span class="type">int</span> age = <span class="number">10</span>; </span><br><span class="line">        <span class="type">float</span> score = <span class="number">93.2F</span>; </span><br><span class="line">        <span class="type">int</span> x,y,z=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>final 数据类型 变量名称 [&#x3D; 值]; final int X&#x3D;1;<br>先声明 、初始化 、使用</p>
<p><strong>2. 类型之间的转换：</strong><br>2.1小——&gt;大：自动类型转换</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">short  y <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">System.out.println(y)<span class="comment">;</span></span><br><span class="line">double x <span class="operator">=</span>  y<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>System.out.println(x);—&gt;小： 强制类型转换</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">at score = <span class="number">13</span>;//<span class="number">13</span>(<span class="type">int</span>)<span class="comment">--&gt;小，到</span></span><br><span class="line">         <span class="keyword">System</span>.<span class="keyword">out</span>.println(score);</span><br><span class="line">         <span class="type">int</span> rs = (<span class="type">int</span>)score; // <span class="number">0.3</span>截取丢失</span><br><span class="line">         <span class="keyword">System</span>.<span class="keyword">out</span>.println(rs);</span><br></pre></td></tr></table></figure>



<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>String在java.lang.String<br><strong>1. 必须掌握： &#x3D; &#x3D; 、 equals() 字符串比较差别</strong>：</p>
<p><strong>2. 熟练进行 简单类型字符串类型</strong><br>String.valueOf(参数) 任意类型+””<br>字符串简单类型（封装类型：parseXxx()）</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">float</span> num = <span class="number">3.1</span>f;</span><br><span class="line">        <span class="built_in">String</span> <span class="built_in">str</span> = <span class="built_in">String</span>.<span class="property">valueOf</span>(num);</span><br><span class="line">        System.<span class="property">out</span>.<span class="property">println</span>(<span class="built_in">str</span>);<span class="comment">//3.1(String)</span></span><br><span class="line">        num =  Float.<span class="property">parseFloat</span>(<span class="built_in">str</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 掌握：String类中常用功能</strong> </p>
<table>
<thead>
<tr>
<th>SN(序号)</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY2hhcmF0Lmh0bWw=">char charAt(int index)<i class="fa fa-external-link-alt"></i></span>返回指定索引处的 char 值。</td>
</tr>
<tr>
<td>2</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29tcGFyZXRvLmh0bWw=">int compareTo(Object o)<i class="fa fa-external-link-alt"></i></span>把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td>3</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29tcGFyZXRvLmh0bWw=">int compareTo(String anotherString)<i class="fa fa-external-link-alt"></i></span>按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td>4</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29tcGFyZXRvaWdub3JlY2FzZS5odG1s">int compareToIgnoreCase(String str)<i class="fa fa-external-link-alt"></i></span>按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td>5</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29uY2F0Lmh0bWw=">String concat(String str)<i class="fa fa-external-link-alt"></i></span>将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td>6</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29udGVudGVxdWFscy5odG1s">boolean contentEquals(StringBuffer sb)<i class="fa fa-external-link-alt"></i></span>当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td>7</td>
<td>[static String copyValueOf(char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29weXZhbHVlb2YuaHRtbA==">] data)<i class="fa fa-external-link-alt"></i></span>返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td>8</td>
<td>[static String copyValueOf(char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29weXZhbHVlb2YuaHRtbA==">] data, int offset, int count)<i class="fa fa-external-link-alt"></i></span>返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td>9</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZW5kc3dpdGguaHRtbA==">boolean endsWith(String suffix)<i class="fa fa-external-link-alt"></i></span>测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td>10</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZXF1YWxzLmh0bWw=">boolean equals(Object anObject)<i class="fa fa-external-link-alt"></i></span>将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td>11</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZXF1YWxzaWdub3JlY2FzZS5odG1s">boolean equalsIgnoreCase(String anotherString)<i class="fa fa-external-link-alt"></i></span>将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td>12</td>
<td>[byte<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZ2V0Ynl0ZXMuaHRtbA==">] getBytes()<i class="fa fa-external-link-alt"></i></span> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td>13</td>
<td>[byte<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZ2V0Ynl0ZXMuaHRtbA==">] getBytes(String charsetName)<i class="fa fa-external-link-alt"></i></span>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td>14</td>
<td>[void getChars(int srcBegin, int srcEnd, char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZ2V0Y2hhcnMuaHRtbA==">] dst, int dstBegin)<i class="fa fa-external-link-alt"></i></span>将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td>15</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaGFzaGNvZGUuaHRtbA==">int hashCode()<i class="fa fa-external-link-alt"></i></span>返回此字符串的哈希码。</td>
</tr>
<tr>
<td>16</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(int ch)<i class="fa fa-external-link-alt"></i></span>返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td>17</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(int ch, int fromIndex)<i class="fa fa-external-link-alt"></i></span>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td>18</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(String str)<i class="fa fa-external-link-alt"></i></span> 返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td>19</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(String str, int fromIndex)<i class="fa fa-external-link-alt"></i></span>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td>20</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW50ZXJuLmh0bWw=">String intern()<i class="fa fa-external-link-alt"></i></span> 返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td>21</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(int ch)<i class="fa fa-external-link-alt"></i></span> 返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td>22</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(int ch, int fromIndex)<i class="fa fa-external-link-alt"></i></span>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td>23</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(String str)<i class="fa fa-external-link-alt"></i></span>返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td>24</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(String str, int fromIndex)<i class="fa fa-external-link-alt"></i></span> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td>25</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGVuZ3RoLmh0bWw=">int length()<i class="fa fa-external-link-alt"></i></span>返回此字符串的长度。</td>
</tr>
<tr>
<td>26</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbWF0Y2hlcy5odG1s">boolean matches(String regex)<i class="fa fa-external-link-alt"></i></span>告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td>27</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVnaW9ubWF0Y2hlcy5odG1s">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<i class="fa fa-external-link-alt"></i></span>测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td>28</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVnaW9ubWF0Y2hlcy5odG1s">boolean regionMatches(int toffset, String other, int ooffset, int len)<i class="fa fa-external-link-alt"></i></span>测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td>29</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVwbGFjZS5odG1s">String replace(char oldChar, char newChar)<i class="fa fa-external-link-alt"></i></span>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td>30</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVwbGFjZWFsbC5odG1s">String replaceAll(String regex, String replacement<i class="fa fa-external-link-alt"></i></span>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td>31</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVwbGFjZWZpcnN0Lmh0bWw=">String replaceFirst(String regex, String replacement)<i class="fa fa-external-link-alt"></i></span> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td>32</td>
<td>[String<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3BsaXQuaHRtbA==">] split(String regex)<i class="fa fa-external-link-alt"></i></span>根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td>33</td>
<td>[String<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3BsaXQuaHRtbA==">] split(String regex, int limit)<i class="fa fa-external-link-alt"></i></span>根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td>34</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3RhcnRzd2l0aC5odG1s">boolean startsWith(String prefix)<i class="fa fa-external-link-alt"></i></span>测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td>35</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3RhcnRzd2l0aC5odG1s">boolean startsWith(String prefix, int toffset)<i class="fa fa-external-link-alt"></i></span>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td>36</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3Vic2VxdWVuY2UuaHRtbA==">CharSequence subSequence(int beginIndex, int endIndex)<i class="fa fa-external-link-alt"></i></span> 返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td>37</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3Vic3RyaW5nLmh0bWw=">String substring(int beginIndex)<i class="fa fa-external-link-alt"></i></span>返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td>38</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3Vic3RyaW5nLmh0bWw=">String substring(int beginIndex, int endIndex)<i class="fa fa-external-link-alt"></i></span>返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td>39</td>
<td>[char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9jaGFyYXJyYXkuaHRtbA==">] toCharArray()<i class="fa fa-external-link-alt"></i></span>将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td>40</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9sb3dlcmNhc2UuaHRtbA==">String toLowerCase()<i class="fa fa-external-link-alt"></i></span>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td>41</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9sb3dlcmNhc2UuaHRtbA==">String toLowerCase(Locale locale)<i class="fa fa-external-link-alt"></i></span> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td>42</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9zdHJpbmcuaHRtbA==">String toString()<i class="fa fa-external-link-alt"></i></span> 返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td>43</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG91cHBlcmNhc2UuaHRtbA==">String toUpperCase()<i class="fa fa-external-link-alt"></i></span>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td>44</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG91cHBlcmNhc2UuaHRtbA==">String toUpperCase(Locale locale)<i class="fa fa-external-link-alt"></i></span>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td>45</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdHJpbS5odG1s">String trim()<i class="fa fa-external-link-alt"></i></span>返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td>46</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdmFsdWVvZi5odG1s">static String valueOf(primitive data type x)<i class="fa fa-external-link-alt"></i></span>返回给定data type类型x参数的字符串表示形式。</td>
</tr>
</tbody></table>
<p>频繁的操作字符串：不建议使用String类，而是使用StringBuilder &amp; StringBuffer</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>1. 算术运算符</strong><br>双目： * &#x2F; %(取余、求模) + -<br>单目： ++ –<br>a 前缀（num++;）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">4</span>;</span><br><span class="line">        ++<span class="built_in">num</span>;</span><br><span class="line">        <span class="built_in">int</span> rs = ++<span class="built_in">num</span>*<span class="number">2</span>;</span><br><span class="line">        System.out.println(rs);<span class="comment">//?</span></span><br></pre></td></tr></table></figure>

<p>b 后缀</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">num</span>++;<span class="comment">//5</span></span><br><span class="line">        <span class="built_in">int</span> rs = <span class="built_in">num</span>++ +x; <span class="comment">//rs = 8  num=6</span></span><br><span class="line">        System.out.println(rs++);<span class="comment">//?</span></span><br><span class="line">        System.out.println(rs);</span><br></pre></td></tr></table></figure>

<p><strong>2. 关系运算符</strong>：true&#x2F;false</p>
<blockquote>
<p>&lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D;(恒等于) !&#x3D;<br>逻辑运算符：true&#x2F;false<br>！（取反） &amp;&amp;（短路且） ||（短路或）</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">3</span>,y=<span class="number">4</span>,z=<span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> rs = x&gt;y&amp;&amp;++z&gt;<span class="number">10</span>;// <span class="keyword">true</span> / <span class="keyword">false</span></span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(z);</span><br></pre></td></tr></table></figure>

<p>算符 &#x3D;<br><strong>3. 赋值运算符</strong><br>赋值运算符： &#x3D;<br>复合赋值运算符： +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">int <span class="keyword">x</span> <span class="operator">=</span> <span class="number">5</span><span class="comment">;</span></span><br><span class="line">//      <span class="keyword">x</span> <span class="operator">=</span> <span class="keyword">x</span> + <span class="number">10</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">x</span>+<span class="operator">=</span><span class="number">10</span><span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="keyword">x</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 三目运算符</strong>：<br>exp1 ? exp2 : exp3;<br>exp1:true exp2;<br>exp1:false exp3;<br><strong>5. 位运算符</strong>：<br>~ 非 |或 &amp;与 ^异或<br>按位~运算符：10100101&#x3D;01011010<br>按位&amp;运算符：1101&amp;1010&#x3D;1000<br>按位|运算符： 1101 | 1010&#x3D; 1111<br>按位异或运算符：1101 ^ 1010 &#x3D; 0111<br><strong>6. 位移运算符</strong><br>&lt;&lt; 3&lt;&lt;3&#x3D;24 &gt;&gt;<br>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方<br><strong>7. 转义字符</strong>： </p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\n</span> 换行 </span><br><span class="line"><span class="string">\r</span> 回车 </span><br><span class="line"><span class="string">\t</span> 水平制表 </span><br><span class="line"><span class="string">\v</span> 垂直 制表 </span><br><span class="line"><span class="string">\”</span> “ </span><br><span class="line"><span class="string">\’</span> ‘ </span><br><span class="line"><span class="string">\</span> <span class="string">\</span></span><br></pre></td></tr></table></figure>

<h1 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java流程控制包括<strong>顺序控制、条件控制和循环控制</strong>。</p>
<ul>
<li>顺序控制，就是从头到尾依次执行每条语句操作。</li>
<li>条件控制，基于条件选择执行语句，比方说，如果条件成立，则执行操作A，或者如果条件成立，则执行操作A，反之则执行操作B。</li>
<li>循环控制，又称为回路控制，根据循环初始条件和终结要求，执行循环体内的操作。</li>
<li>分支结构:  顺序结构只能顺序执行，不能进行判断和选择，因此需要分支结构。</li>
</ul>
<p>Java有两种分支结构：</p>
<ul>
<li><p>if语句</p>
</li>
<li><p>switch语句</p>
</li>
</ul>
<p>Java中有三种主要的循环结构：</p>
<ul>
<li><p>while循环</p>
</li>
<li><p>do…while循环</p>
</li>
<li><p>for循环</p>
</li>
</ul>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hgd.study2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java的流程控制：顺序结构 分之机构 循环结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuTiger 顺序结构：通过debug模式可以看出java程序的运行时顺序结构的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *         分支结构：if语句</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessControl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// IfStudy();</span></span><br><span class="line">        <span class="comment">// SwitchCaseStudy();</span></span><br><span class="line">        <span class="comment">// WhileStudy();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * IF语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">IfStudy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 根据条件表达的世界(true||false)来判断是否进入语句块 if(条件表达式)&#123; 语句块 &#125; 继续执行后面的语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;后面需要执行的语句&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * if else 语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// system.in就是标准输入，可以获取从键盘输入的值</span></span><br><span class="line">        <span class="comment">// 通过scanner(jdk提供给我们的工具)来处理获取到的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入分数!&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sc.nextInt();<span class="comment">// 把用户输入的数赋值给j</span></span><br><span class="line">        System.out.println(<span class="string">&quot;控制台获取到的值是：&quot;</span> + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;通过&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当if else 执行后需要执行的内容&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * if else if else if ...else</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 场景：将一个5(score)分制分为 :5分的评价等级A 4==B 3==C 其他是D</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sca.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score == <span class="number">5</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score == <span class="number">4</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score == <span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 练习：百分制系统 90-100 优秀 75-89 良好 60-74 合格 其他 不合格</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score1</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (score1 &gt;= <span class="number">0</span> &amp;&amp; score1 &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score1 &gt;= <span class="number">90</span> &amp;&amp; score1 &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score1 &gt;= <span class="number">75</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score1 &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;合格&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不合格&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * switch case</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SwitchCaseStudy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 分支语句：switch case key：需要比较的表达式 value：与表达式进行比较的值</span></span><br><span class="line"><span class="comment">         * 执行流程：如果key和value比较的结果为true，那么将执行case部分的代码，case部分可以有多个 类似于else if 部分</span></span><br><span class="line"><span class="comment">         * 区别是key和value之间的比较只能是== default部分是不满足以上任何去执行的代码 ，类似于else</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * switch 后面括号中的表达式的值必须是符合byte，char，short，int类型的常量表达式 jdk1.7以后可以使用string</span></span><br><span class="line"><span class="comment">         * ，而不能用浮点型或long类型</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * switch(key) &#123; case value: break; default: break; &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 场景：将一个5(score)分制分为 :5分的评价等级A 4==B 3==C 其他是D</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 标准写法 break不能少 跳出当前语句块，如果没有break会直接进入下一个case语句</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * while 循环和do while</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">WhileStudy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 执行流程： 当条件表达式为true的时候进入代码块，执行需要执行的代码 当条件表达式为false的时候执行后面的语句</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * while(条件表达式)&#123; 需要执行的代码部分 &#125; 后面的语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 场景：输入1-100的整数分析：给输出的值一个变量I，当i在1-100之间的时候输出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 循环的起点</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">// 给出循环的步长</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印结束&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * do while</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * do&#123;</span></span><br><span class="line"><span class="comment">         * &#125;while(条件表达式)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;<span class="comment">//语句块中的内容无论条件是否满足都会先执行一次</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a&lt;=<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ForStudy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 场景：打印1-100 int i=1是循环的起点 i++ 循环的补偿 i&lt;=100 循环的条件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p>
<p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<p>你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，….，number99。</p>
<p>本教程将为大家介绍 Java 数组的声明、创建和初始化，并给出其对应的代码。</p>
<hr>
<h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<p>dataType[] arrayRefVar;   &#x2F;&#x2F; 首选的方法 或 dataType arrayRefVar[];  &#x2F;&#x2F; 效果相同，但不是首选方法</p>
<p><strong>注意:</strong> 建议使用 <strong>dataType[] arrayRefVar</strong> 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C&#x2F;C++ 语言 ，在Java中采用是为了让 C&#x2F;C++ 程序员能够快速理解java语言。</p>
<p>实例</p>
<p>下面是这两种语法的代码示例：</p>
<p>double[] myList;         &#x2F;&#x2F; 首选的方法 或 double myList[];         &#x2F;&#x2F;  效果相同，但不是首选方法</p>
<hr>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java语言使用new操作符来创建数组，语法如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">arrayRefVar</span> <span class="operator">=</span> new dataType[arraySize]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 dataType[arraySize] 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar <span class="operator">=</span> new dataType[arraySize]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>另外，你还可以使用如下的方式创建数组。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">dataType[] <span class="built_in">array</span>RefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>

<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<p>实例</p>
<p>下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。</p>
<p>TestArray.java 文件代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 数组大小</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 定义数组</span></span><br><span class="line">      <span class="type">double</span>[] myList = <span class="keyword">new</span> <span class="title class_">double</span>[size];</span><br><span class="line">      myList[<span class="number">0</span>] = <span class="number">5.6</span>;</span><br><span class="line">      myList[<span class="number">1</span>] = <span class="number">4.5</span>;</span><br><span class="line">      myList[<span class="number">2</span>] = <span class="number">3.3</span>;</span><br><span class="line">      myList[<span class="number">3</span>] = <span class="number">13.2</span>;</span><br><span class="line">      myList[<span class="number">4</span>] = <span class="number">4.0</span>;</span><br><span class="line">      myList[<span class="number">5</span>] = <span class="number">34.33</span>;</span><br><span class="line">      myList[<span class="number">6</span>] = <span class="number">34.0</span>;</span><br><span class="line">      myList[<span class="number">7</span>] = <span class="number">45.45</span>;</span><br><span class="line">      myList[<span class="number">8</span>] = <span class="number">99.993</span>;</span><br><span class="line">      myList[<span class="number">9</span>] = <span class="number">11123</span>;</span><br><span class="line">      <span class="comment">// 计算所有元素的总和</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">         total += myList[i];</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;总和为： &quot;</span> + total);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">总和为： <span class="number">11367.373</span></span><br></pre></td></tr></table></figure>

<p>下面的图片描绘了数组 myList。这里 myList 数组里有 10 个 double 元素，它的下标从 0 到 9。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q0221Q5602.jpg" alt="java数组结构说明"></p>
<hr>
<h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。</p>
<p>示例</p>
<p>该实例完整地展示了如何创建、初始化和操纵数组：</p>
<p>TestArray.java 文件代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 打印所有数组元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         System.out.println(myList[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算所有元素的总和</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         total += myList[i];</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Total is &quot;</span> + total);</span><br><span class="line">      <span class="comment">// 查找最大元素</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> myList[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (myList[i] &gt; max) max = myList[i];</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Max is &quot;</span> + max);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">2</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">3</span>.<span class="number">4</span></span><br><span class="line"><span class="attribute">3</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">Total</span> is <span class="number">11</span>.<span class="number">7</span></span><br><span class="line"><span class="attribute">Max</span> is <span class="number">3</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h2><p>JDK 1.5 引进了一种新的循环类型，被称为 foreach 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<p>示例</p>
<p>该实例用来显示数组myList中的所有元素：</p>
<p>TestArray.java 文件代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 打印所有数组元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">double</span> element: myList) &#123;</span><br><span class="line">         System.out.println(element);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">2</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">3</span>.<span class="number">4</span></span><br><span class="line"><span class="attribute">3</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><p>数组可以作为参数传递给方法。</p>
<p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p>
<p>printArray(new int[]{3, 1, 2, 6, 4, 2});</p>
<hr>
<h2 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverse(<span class="type">int</span>[] list) &#123;</span><br><span class="line">  <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[list.length];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = result.length - <span class="number">1</span>; i &lt; list.length; i++, j--) &#123;</span><br><span class="line">    result[j] = list[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例中 result 数组作为函数的返回值。</p>
<hr>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<p>String str[][] &#x3D; new String[3][4];</p>
<h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><ol>
<li>直接为每一维分配空间，格式如下：</li>
</ol>
<p>type arrayName &#x3D; new type[arraylenght1][arraylenght2];</p>
<p>type 可以为基本数据类型和复合数据类型，arraylenght1 和 arraylenght2 必须为正整数，arraylenght1 为行数，arraylenght2 为列数。</p>
<p>例如：</p>
<p>int a[][] &#x3D; new int[2][3];</p>
<p>解析：</p>
<p>二维数组 a 可以看成一个两行三列的数组。</p>
<ol start="2">
<li>从最高维开始，分别为每一维分配空间，例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s[][] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>][];</span><br><span class="line">s[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">s[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Luck&quot;</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;to&quot;</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;you&quot;</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><strong>s[0]&#x3D;new String[2]</strong> 和 <strong>s[1]&#x3D;new String[3]</strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0&#x3D;new String(“Good”)</strong> 等操作。</p>
<h3 id="多维数组的引用（以二维数组为例）"><a href="#多维数组的引用（以二维数组为例）" class="headerlink" title="多维数组的引用（以二维数组为例）"></a>多维数组的引用（以二维数组为例）</h3><p>对二维数组中的每个元素，引用方式为 **arrayName[index1][index2]**，例如：</p>
<p>num[1][0];</p>
<hr>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<p>具体说明请查看下表：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法和说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>**public static int binarySearch(Object[] a, Object key)**用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td>
</tr>
<tr>
<td>2</td>
<td>**public static boolean equals(long[] a, long[] a2)*<em>如果两个指定的 long 型数组彼此</em>相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td>3</td>
<td>**public static void fill(int[] a, int val)**将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td>4</td>
<td>**public static void sort(Object[] a)**对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody></table>
<h2 id="笔记列表"><a href="#笔记列表" class="headerlink" title="笔记列表"></a>笔记列表</h2><ol>
<li><p>数组倒序实例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test2 &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)&#123;</span><br><span class="line">        <span class="type">int</span>[] test= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : test) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;\n&quot;);</span><br><span class="line">        test = Test2.reverse(test);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : test) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">int</span>[] reverse(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="built_in">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j=result.length<span class="number">-1</span>; i &lt; arr.length; i++,j<span class="comment">--) &#123;</span></span><br><span class="line">            result[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">// 声明二维数组：有两行，列数待定，数组结构 = &#123; &#123; &#125;, &#123; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">String</span> s[][] = new <span class="symbol">String</span>[<span class="number">2</span>][]; </span><br><span class="line"></span><br><span class="line">// 确定每行的元素个数，第一行有<span class="number">2</span>个元素，第二行有<span class="number">3</span>个元素，</span><br><span class="line"></span><br><span class="line">// 数组结构 = &#123;&#123;<span class="string">&quot;E1&quot;</span>, <span class="string">&quot;E2&quot;</span>&#125;, &#123;<span class="string">&quot;E1&quot;</span>, <span class="string">&quot;E2&quot;</span>, <span class="string">&quot;E3&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = new <span class="symbol">String</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = new <span class="symbol">String</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现数组和字符串的转换处理</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String args[]) &#123;</span><br><span class="line">        String <span class="built_in">str</span> = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="built_in">char</span>[] data = <span class="built_in">str</span>.toCharArray();<span class="comment">// 将字符串转为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; data.length; x++) &#123;</span><br><span class="line">            System.out.<span class="keyword">print</span>(data[x] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            data[x] -= <span class="number">32</span>;</span><br><span class="line">            System.out.<span class="keyword">print</span>(data[x] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>冒泡排序</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> BubbleSort &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数。</span></span><br><span class="line"><span class="comment"> * @param args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">26</span>,<span class="number">15</span>,<span class="number">29</span>,<span class="number">66</span>,<span class="number">99</span>,<span class="number">88</span>,<span class="number">36</span>,<span class="number">77</span>,<span class="number">111</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; arr.length<span class="number">-1</span>;i++) &#123;//外层循环控制排序趟数</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; arr.length-i<span class="number">-1</span>;j++) &#123;</span><br><span class="line">                        //内层循环控制每一趟排序多少次</span><br><span class="line">                // 把小的值交换到前面</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="keyword">temp</span> = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = <span class="keyword">temp</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(&quot;第&quot;+(i+<span class="number">1</span>)+&quot;次排序结果：&quot;);</span><br><span class="line">                                //列举每次排序的数据</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;arr.length;a++) &#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.print(arr[a] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;最终排序结果：&quot;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; arr.length;a++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(arr[a] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择排序：（比冒泡排序更快，运行次数更少）：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="keyword">Start</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">20</span>,<span class="number">60</span>,<span class="number">51</span>,<span class="number">81</span>,<span class="number">285</span>,<span class="number">12</span>,<span class="number">165</span>,<span class="number">51</span>,<span class="number">81</span>,<span class="number">318</span>,<span class="number">186</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a:arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;\n&quot;+&quot;---------------从大到小---------------&quot;);</span><br><span class="line">        </span><br><span class="line">        arr=toSmall(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a:arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;\n&quot;+&quot;---------------从小到大---------------&quot;);</span><br><span class="line">        </span><br><span class="line">        arr=toBig(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a:arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(a+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//    从大到小</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">int</span>[] toSmall(<span class="type">int</span>[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">//遍历数组里除最后一个的其他所有数，因为最后的对象没有与之可以相比较的数</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">/*遍历数组里没有排序的所有数，并与上一个数进行比较</span></span><br><span class="line"><span class="comment"> *“k=i+1”因为自身一定等于自身，所以相比没有意义</span></span><br><span class="line"><span class="comment"> *而前面已经排好序的数，在比较也没有意义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i+<span class="number">1</span>;k&lt;arr.length;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[k]&lt;arr[i])//交换条件（排序条件）</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> number=arr[i];</span><br><span class="line">                    arr[i]=arr[k];</span><br><span class="line">                    arr[k]=number;</span><br><span class="line">                &#125;//交换</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">//    从小到大</span><br><span class="line">//和前面一样</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">int</span>[] toBig(<span class="type">int</span>[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i+<span class="number">1</span>;k&lt;arr.length;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[k]&gt;arr[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> number=arr[i];</span><br><span class="line">                    arr[i]=arr[k];</span><br><span class="line">                    arr[k]=number;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：</p>
<ul>
<li>** 给数组赋值：通过fill方法。</li>
<li>** 对数组排序：通过sort方法,按升序。</li>
<li>** 比较数组：通过equals方法比较数组中元素值是否相等。</li>
<li>** 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TestArrays</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> output(<span class="built_in">int</span>[] <span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.print(<span class="built_in">array</span>[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">array</span> = new <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 填充数组</span></span><br><span class="line">        Arrays.fill(<span class="built_in">array</span>, <span class="number">5</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;填充数组：Arrays.fill(array, 5)：&quot;</span>);</span><br><span class="line">        TestArrays.output(<span class="built_in">array</span>);</span><br><span class="line">        <span class="comment">// 将数组的第2和第3个元素赋值为8</span></span><br><span class="line">        Arrays.fill(<span class="built_in">array</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;将数组的第2和第3个元素赋值为8：Arrays.fill(array, 2, 4, 8)：&quot;</span>);</span><br><span class="line">        TestArrays.output(<span class="built_in">array</span>);</span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">array</span>1 = &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="comment">// 对数组的第2个到第6个进行排序进行排序</span></span><br><span class="line">        Arrays.sort(<span class="built_in">array</span>1, <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;对数组的第2个到第6个元素进行排序进行排序：Arrays.sort(array,2,7)：&quot;</span>);</span><br><span class="line">        TestArrays.output(<span class="built_in">array</span>1);</span><br><span class="line">        <span class="comment">// 对整个数组进行排序</span></span><br><span class="line">        Arrays.sort(<span class="built_in">array</span>1);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;对整个数组进行排序：Arrays.sort(array1)：&quot;</span>);</span><br><span class="line">        TestArrays.output(<span class="built_in">array</span>1);</span><br><span class="line">        <span class="comment">// 比较数组元素是否相等</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;比较数组元素是否相等:Arrays.equals(array, array1):&quot;</span> + <span class="string">&quot;\n&quot;</span> + Arrays.equals(<span class="built_in">array</span>, <span class="built_in">array</span>1));</span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">array</span>2 = <span class="built_in">array</span>1.clone();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;克隆后数组元素是否相等:Arrays.equals(array1, array2):&quot;</span> + <span class="string">&quot;\n&quot;</span> + Arrays.equals(<span class="built_in">array</span>1, <span class="built_in">array</span>2));</span><br><span class="line">        <span class="comment">// 使用二分搜索算法查找指定元素所在的下标（必须是排序好的，否则结果不正确）</span></span><br><span class="line">        Arrays.sort(<span class="built_in">array</span>1);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;元素3在array1中的位置：Arrays.binarySearch(array1, 3)：&quot;</span> + <span class="string">&quot;\n&quot;</span> + Arrays.binarySearch(<span class="built_in">array</span>1, <span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 如果不存在就返回负数</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;元素9在array1中的位置：Arrays.binarySearch(array1, 9)：&quot;</span> + <span class="string">&quot;\n&quot;</span> + Arrays.binarySearch(<span class="built_in">array</span>1, <span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">填充数组：Arrays.fill(<span class="built_in">array</span>, <span class="number">5</span>)：</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> </span><br><span class="line">将数组的第<span class="number">2</span>和第<span class="number">3</span>个元素赋值为<span class="number">8</span>：Arrays.fill(<span class="built_in">array</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>)：</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">对数组的第<span class="number">2</span>个到第<span class="number">6</span>个元素进行排序进行排序：Arrays.sort(<span class="built_in">array</span>,<span class="number">2</span>,<span class="number">7</span>)：</span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">6</span> <span class="number">12</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line">对整个数组进行排序：Arrays.sort(<span class="built_in">array</span>1)：</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">12</span> </span><br><span class="line">比较数组元素是否相等:Arrays.equals(<span class="built_in">array</span>, <span class="built_in">array</span>1):</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">克隆后数组元素是否相等:Arrays.equals(<span class="built_in">array</span>1, <span class="built_in">array</span>2):</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">元素<span class="number">3</span>在<span class="built_in">array</span>1中的位置：Arrays.binarySearch(<span class="built_in">array</span>1, <span class="number">3</span>)：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">元素<span class="number">9</span>在<span class="built_in">array</span>1中的位置：Arrays.binarySearch(<span class="built_in">array</span>1, <span class="number">9</span>)：</span><br><span class="line"><span class="number">-9</span></span><br></pre></td></tr></table></figure>

<h1 id="Java面向对象基础知识总结"><a href="#Java面向对象基础知识总结" class="headerlink" title="Java面向对象基础知识总结"></a>Java面向对象基础知识总结</h1></li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>将跟对象有关的功能都封装在其内</p>
<p>面向对象三大特征：封装，继承，多态</p>
<p>找对象，创建对象，使用对象，并维护对象之间的关系</p>
<ol>
<li><p>类：对现实中事物的描述</p>
</li>
<li><p>对象：就是实实在在 存在的事物映射到java中，描述就是class定义的类具体对象就是对应java在堆内存new建立的实体</p>
</li>
<li><p>类与对象：设计图纸就是类，里面包含对象的描述：比如说车的颜色，轮胎数，发动机….</p>
<blockquote>
<p>Note：对象建立的时候，属性值都会先置为null，显式初始化后才会变成具体的值</p>
</blockquote>
</li>
</ol>
<h2 id="成员变量VS局部变量"><a href="#成员变量VS局部变量" class="headerlink" title="成员变量VS局部变量"></a>成员变量VS局部变量</h2><p>根据定义变量位置的不同，可以将变量分为成员变量和局部变量</p>
<ul>
<li>成员变量是在类范围内定义的变量</li>
<li>局部变量是在一个方法内定义的变量</li>
</ul>
<p>成员变量可以分为：</p>
<ul>
<li>实例属性 （不用static修饰） 随着实例属性的存在而存在</li>
<li>类属性 （static修饰）随着类的存在而存在</li>
</ul>
<p>成员变量无需显式初始化，系统会自动对其进行默认初始化</p>
<p>局部变量可分为：</p>
<ul>
<li>形参（形式参数）&#x2F;&#x2F;在整个方法内有效</li>
<li>方法局部变量 （方法内定义）&#x2F;&#x2F; 从定义这个变量开始到方法结束这一段时间内有效  </li>
<li>代码块局部变量 （代码块内定义）  &#x2F;&#x2F;从定义这个变量开始到代码块结束这一段时间内有效</li>
</ul>
<p>局部变量除了形参外，都必须显示初始化，也就是要指定一个初始值，否则不能访问。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> object;</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line"> * 成员变量和局部变量</span><br><span class="line"> * </span><br><span class="line"> * */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticname</span> <span class="operator">=</span> <span class="string">&quot;类属性&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">nostaticname</span> <span class="operator">=</span> <span class="string">&quot;实例属性&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有初始化的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticname1;</span><br><span class="line">    <span class="keyword">public</span> String nostaticname1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//在方法中定义一个局部变量i</span></span><br><span class="line">        <span class="comment">//int i;</span></span><br><span class="line">        <span class="comment">//直接输出是输出不出来的，因为没有初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(i);</span></span><br><span class="line">        <span class="comment">//定义一个局部变量i并初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//输出i</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义了一个静态的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infos</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*第一问：类属性和实例属性的范围一样吗？*/</span></span><br><span class="line">        <span class="comment">//在没创建实例之前 可以调用类属性,但不能调用实例属性</span></span><br><span class="line">        System.out.println(VariableTest.staticname);<span class="comment">//结果：类属性</span></span><br><span class="line">        <span class="comment">//实例化对象之后,就可以调用实例属性了</span></span><br><span class="line">        <span class="type">VariableTest</span> <span class="variable">vt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VariableTest</span>();</span><br><span class="line">        System.out.println(vt.nostaticname);<span class="comment">//结果：实例属性</span></span><br><span class="line">        <span class="comment">/*--- 结论：在成员变量中，类属性的范围比实例属性大一点 ---*/</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*第二问：成员变量需要显性初始化吗？*/</span></span><br><span class="line">        <span class="comment">//直接调用没有初始化的类属性</span></span><br><span class="line">        System.out.println(VariableTest.staticname1);<span class="comment">//结果：null</span></span><br><span class="line">        <span class="comment">//用实例化对象调用没有初始化的实例属性</span></span><br><span class="line">        System.out.println(vt.nostaticname1);<span class="comment">//结果：null</span></span><br><span class="line">        <span class="comment">/*--- 结论：成员变量会自动隐性初始化，赋给变量一个默认值  ---*/</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*第三问：如果用实例化后的对象去调用类属性会怎么样？*/</span></span><br><span class="line">        <span class="comment">//vt.staticname; </span></span><br><span class="line">        <span class="comment">//这样会报错</span></span><br><span class="line">        <span class="comment">//Syntax error, insert &quot;VariableDeclarators&quot; to complete LocalVariableDeclaration</span></span><br><span class="line">        <span class="comment">//翻译：语法错误,插入“变量声明符”来完成局部变量声明</span></span><br><span class="line">        <span class="comment">/*为什么会报错。一开始我以为是因为eclipse出错了</span></span><br><span class="line"><span class="comment">         *后来我直接用文本文档重写了一个test</span></span><br><span class="line"><span class="comment">         *编译文件后，报不是语句的错，然后我又试了一下</span></span><br><span class="line"><span class="comment">         *VariableTest.staticname</span></span><br><span class="line"><span class="comment">         *也是报错，说明这种写法是不正确的，具体为什么有待研究*/</span></span><br><span class="line">        vt.staticname = <span class="string">&quot;改变了的类属性&quot;</span>;</span><br><span class="line">        <span class="comment">//如果同时给类属性赋值，就不会报错...有警告</span></span><br><span class="line">        <span class="comment">//The static field Variable Test.static name should be accessed in a static way</span></span><br><span class="line">        <span class="comment">//翻译：静态字段变量测试。静态的名字应该在一个静态方法访问</span></span><br><span class="line">        System.out.println(vt.staticname);<span class="comment">//结果：改变了的类属性</span></span><br><span class="line">        <span class="comment">//这样就不会报错，但是会有警告，同上↑</span></span><br><span class="line">        <span class="comment">/*结论：用实例化后的对象调用类属性，格式正确的情况下，是可以调用的，但有警告</span></span><br><span class="line"><span class="comment">         *通过对象调用类属性，同样可以改变类属性的值*/</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义在方法中的局部变量</span></span><br><span class="line">        <span class="comment">/*第四问：定义在方法中的局部变量，出了方法还能访问吗？*/</span></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        vt.info();<span class="comment">//结果：10</span></span><br><span class="line">        <span class="comment">//现在还能用info中的i吗？</span></span><br><span class="line">        <span class="comment">//System.out.println(i);</span></span><br><span class="line">        <span class="comment">//报错：i cannot be resolved to a variable</span></span><br><span class="line">        <span class="comment">//翻译：i 不能转换成一个变量</span></span><br><span class="line">        <span class="comment">/*结论：定义在方法中的局部变量，出了方法就不能被访问了*/</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义在代码块中的局部变量</span></span><br><span class="line">        <span class="comment">/*第五问：定义在代码块中的局部变量，出了代码块还能访问吗？*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">            System.out.println(j);<span class="comment">//结果：11</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出了代码块</span></span><br><span class="line">        <span class="comment">//System.out.println(j);</span></span><br><span class="line">        <span class="comment">//同样报错，内容与上面的一样</span></span><br><span class="line">        <span class="comment">/*定义在代码块中的局部变量，出了代码块就不能访问了*/</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后续：一个静态方法</span></span><br><span class="line">        infos();<span class="comment">//结果：20</span></span><br><span class="line">        <span class="comment">//这样依然报错</span></span><br><span class="line">        <span class="comment">//System.out.println(i);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java允许局部变量和成员变量重名，局部变量会覆盖成员变量的值</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> object;</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line"> * 局部变量覆盖成员变量</span><br><span class="line"> * */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableCover</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*当实例变量与方法中的局部变量同名时，</span></span><br><span class="line"><span class="comment">     *局部变量的值会覆盖实例变量*/</span></span><br><span class="line">    <span class="comment">//定义实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> <span class="string">&quot;合肥&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">citys</span> <span class="operator">=</span> <span class="string">&quot;滁州&quot;</span>;</span><br><span class="line">    <span class="comment">//定义一个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> <span class="string">&quot;蚌埠&quot;</span>;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//方法中的同名局部变量会覆盖实例变量</span></span><br><span class="line">        System.out.println(city);<span class="comment">//结果：蚌埠</span></span><br><span class="line">        <span class="comment">//要想调用实例变量，可以用this</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.city);<span class="comment">//结果：合肥</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">citys</span> <span class="operator">=</span> <span class="string">&quot;南京&quot;</span>;</span><br><span class="line">        <span class="comment">//方法中的同名局部变量会覆盖实例变量</span></span><br><span class="line">        System.out.println(citys);<span class="comment">//结果：南京</span></span><br><span class="line">        <span class="comment">//可以通过类名调用被覆盖的类属性</span></span><br><span class="line">        System.out.println(VariableCover.citys);<span class="comment">//结果：滁州</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> <span class="string">&quot;上海&quot;</span>;</span><br><span class="line">        System.out.println(city);<span class="comment">//结果：上海</span></span><br><span class="line">        <span class="comment">//这样也可以</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">VariableCover</span>().city);<span class="comment">//结果：合肥</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VariableCover</span>().function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名对象：没有定义名称的对象"><a href="#匿名对象：没有定义名称的对象" class="headerlink" title="匿名对象：没有定义名称的对象"></a>匿名对象：没有定义名称的对象</h2><p>匿名对象的传值调用：调用结束后，在堆内存新生成的对象成为垃圾（无指向）,因此过一段时间就会被垃圾回收机制回收.</p>
<p>new Car().run(); </p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>隐藏对象的属性和实现细节，仅仅提供公共访问方式；关键字：private 权限修饰符，只在本类中有效私有只是封装的一种表现形式；一般情况下，把属性都隐藏，提供公共访问方式访问；对访问的数据进行操作，提高代码的健壮性。</p>
<ol>
<li>对外提供公开的用于设置对象属性的public方法</li>
</ol>
<p>​        设置set     获取get</p>
<ol start="2">
<li>在set方法中加入逻辑判断，过滤掉非法数据。</li>
<li>将所有的成员变量封装加上private，提供get、set方法</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>函数名和类名一致，不能用return；对象一建立就会调用构造函数，可以用于对特定对象进行初始化；</p>
<p>若类中没有定义构造函数，系统会默认加入一个空参数的构造函数；构造函数也可以私有化，私有化后不能使用该函数创建对象；如果所有构造函数都私有化，那么就不能创建对象；一般方法是对象调用才运行，可以被调用多次；构造代码块：给所有对象的共性进行初始化，对象一建立就运行，优先于构造函数执行</p>
<p>  构造函数的最大作用就是创建对象时完成初始化，当我们在new一个对象并传入参数的时候，会自动调用构造函数并完成参数的初始化。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>代表当前调用对象（当变量前面加了this，该变量可以认为是成员变量）</p>
<p>当本类功能内部需要使用本类对象时，都用this来表示</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态，修饰成员（包括变量和方法,不能修饰局部），表示共性数据可以被类名调用：类名.静态成员被所有对象共享，只占一块内存（方法区，共享区，数据区）随着类的加载而加载，随着类的消失而消失，生命周期最长优先于对象存在被所有对象所共享可以直接被类名调用（可以不创建对象）</p>
<p>String name；&#x2F;&#x2F;成员变量，实例变量，随着对象的建立而存在</p>
<p>static String country &#x3D; “CN”;&#x2F;&#x2F;静态变量，类变量</p>
<h2 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a>静态变量和成员变量的区别</h2><ol>
<li>存放位置：</li>
</ol>
<p>实例变量随着对象的建立存在于堆内存中，</p>
<p>类变量随着类的加载存在于方法区中</p>
<ol start="2">
<li>生命周期：</li>
</ol>
<p>实例变量随着对象消失而消失</p>
<p>类变量随着类消失而消失</p>
<ol start="3">
<li>使用注意事项：</li>
</ol>
<p>静态方法只能访问静态成员</p>
<p>静态方法中不可以定义this, super关键字（因为静态有限于对象存在）</p>
<p>主函数是静态的，作为程序入口，可以被jvm调用</p>
<ul>
<li>利：    对共享数据进行单独空间存储，节省空间.</li>
</ul>
<p>可以直接被类名调用</p>
<ul>
<li>弊：    生命周期过长，访问出现局限性（只能访问静态）</li>
</ul>
<p>public static void main(String[] args)解析：</p>
<p>&#x2F;*</p>
<p>public：代表这该函数访问权限最大</p>
<p>static：代表主函数随着类的加载就已经存在</p>
<p>void：没有返回值</p>
<p>main:特殊单词，可以被jvm识别</p>
<p>String[] args:参数是一个数组，该数组中的元素是字符串</p>
<p>*&#x2F;</p>
<p>静态变量：当对象中出现共享数据时</p>
<p>静态函数： 当功能内部没有访问到非静态数据时</p>
<p>若编译时，当前调用的class不存在时，会先去当前目录下找相应的java文件，如果有，则会直接编译，生成class文件</p>
<p>静态代码块：随着类的加载而执行，只执行一次，优先于主函数</p>
<p>用于给类进行初始化</p>
<p>构造代码块会执行多次；</p>
<p>运行顺序：静态代码块，构造代码块，构造函数</p>
<p>一个对象的建立过程：</p>
<p>Person p&#x3D; new Person(“zhangsan”,20);</p>
<ol>
<li>找到Person.class文件并加载到内存中</li>
<li>执行static代码块</li>
<li>在堆内存中开辟空间，分配内存地址（main函数开始）</li>
<li>在堆内存中建立对象的特有属性，并进行默认初始化</li>
<li>对属性进行显示初始化</li>
<li>对对象进行构造代码块初始化</li>
<li>对对象进行对应的构造函数初始化</li>
<li>将内存地址赋值给栈内存中的p变量</li>
</ol>
<p>初始化过程：默认初始化，显式初始化，构造初始化</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>将类的共有属性提取出来，将之变为超类，父类提高了代码复用性、让类与类之间产生了关系，因此有了多态的特性，只支持单继承，不支持多继承。</p>
<p>（容易带来安全隐患：当多个父类中定义了相同功能，但内容不同时，子类不确定执行哪个功能）</p>
<p>但是java保留了这种机制，并用另一种体现形式来完成表示(接口的多实现);java支持多层继承，爷爷类-父亲类-孙子类，也叫做继承体系;在具体调用时，只需创建最子类的对象；父类可能不能创建对象;创建子类对象可以使用更多功能，包括共有的和特有的;查阅父类功能，创建子类对象使用功能; 聚集，聚合，组合</p>
<ol>
<li>若子类和父类有同名变量：</li>
</ol>
<p>子类访问本类中的变量，前面加this；</p>
<p>子类要访问父类的变量，前面加super；</p>
<p>若变量不同名，则this和super（如果父类中有该变量）指向同一个变量</p>
<p>若子类和父类中函数同名，则会使用子类的函数；父类的函数被覆盖（重写,overide）</p>
<p>沿袭父类功能，但是重写功能内容.</p>
<ol start="2">
<li>子类方法覆盖父类方法条件：</li>
</ol>
<p>静态只能覆盖静态</p>
<p>必须保证子类权限大于父类,（父类的权限不能为(private)）</p>
<p>public &gt;默认权限&gt;private</p>
<p>重载：只看参数列表</p>
<p>重写：两个方法需要一模一样(包括返回值，参数类型)</p>
<p>子类和父类的构造函数：绝对不能重写！</p>
<p>父类先于子类加载，因为在子类的所有构造函数之前都有一句隐世的super()（空参数的父类构造函数）；</p>
<p>父类中若有空参数的父类构造函数，子类中的构造函数可以不写super();</p>
<p>父类中若没有空参数的构造函数，则子类的每个构造函数第一句需要显式的写明super(XXX);</p>
<p>父类中的数据子类可以直接获取，子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的；</p>
<p>因此子类在对象初始化时，要先访问父类中的构造函数。</p>
<p>this();或者super();都只能写在第一行，只能存在一个.</p>
<p>子类中至少有一个构造函数会访问父类中的构造函数；</p>
<p>extends Object（所有类的上帝，默认父类）</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>修饰类，函数，变量</p>
<p>被修饰的类不可以被继承</p>
<p>被修饰的方法不可以被复写</p>
<p>被修饰的变量是一个常量，只能赋值一次，可以修饰成员变量和局部变量</p>
<p>所有字母都大写</p>
<p>修饰类：public final</p>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>abstract class Student&#x2F;&#x2F;抽象方法必须存在于抽象类中，不能用该类创建对象，因为没有意义</p>
<p>{</p>
<p>abstract void study();&#x2F;&#x2F;抽象方法，内容待定，要被使用，必须有子类复写该方法</p>
<p>}</p>
<p>子类如果不覆盖所有的抽象方法，则子类还是一个抽象类</p>
<p>父类可以强制子类执行抽象方法；</p>
<p>抽象类和一般类：抽象类多了一些不确定的功能（抽象方法），需要子类具体执行</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Interface,不能创建对象</p>
<p>特点：</p>
<p>1.所以变量都是public static final</p>
<p>2.所有方法都是public abstract class interfaceTest implements Interface1</p>
<p>接口可以被类多实现，一个类中可以实现多个interface：因为多个接口的方法都没有主体；</p>
<p>一个类在继承一个父类的同时，可以实现多个接口；</p>
<p>接口之间可以继承，并且一个接口可以继承多个接口</p>
<p>接口的特点：降低了耦合性</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>函数的多态体现：重载和覆盖</p>
<ol>
<li>多态的体现：</li>
</ol>
<p>父类的引用指向了自己的子类对象</p>
<p>父类的引用也可以接受自己的子类对象</p>
<ol start="2">
<li>多态的前提：</li>
</ol>
<p>类与类有关系，要么是继承，要么是实现;</p>
<p>存在覆盖;</p>
<ol start="3">
<li>多态的好处：</li>
</ol>
<p>提高了程序的扩展性，但是只能使用父类的引用访问父类中的成员</p>
<ol start="4">
<li>多态的应用:</li>
</ol>
<p>多态中（非静态）成员函数的特点：</p>
<p>编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，则编译可以通过</p>
<p>运行时期：参阅对象所属类中是否有调用方法</p>
<p>Fu z &#x3D; new zi();</p>
<p>编译时，看左边的Fu类</p>
<p>运行时，看右边的zi类</p>
<p>面试注意点：</p>
<p>多态中成员变量和（静态）成员函数的特点：</p>
<p>无论编译或运行，都参考左边</p>
<p>静态绑定，只看引用，只参考左边；</p>
<p>动态绑定，</p>
<p>如果每个子类每次都要调用父类中的共性方法，可以在主函数中或者一个类中创建一个共性方法，</p>
<p>参数以父类对象为准，调用的时候只需要将子类对象传入即可.</p>
<p>object类：所有类的直接或间接父类</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
<p>内部类不用建立对象就可以访问外部类的成员变量和函数，包括私有；外部类要访问内部类，必须建立内部类对象；建立在非所属类中时，需先建立外部类，Outer.Inner in &#x3D; new Outer().new Inner();内部类可以私有</p>
<p>内部类访问外部类成员变量    Outer.this.x。</p>
<p>注意：当内部类中定义了静态成员，则该内部类必须也是静态的</p>
<p>当外部类中的静态方法访问内部类时，内部类也必须是静态的</p>
<p>局部内部类不能静态</p>
<p>内部类定义在局部时，不可以被成员修饰符修饰</p>
<p>可以直接访问外部类中的成员</p>
<p>但是不可以访问所在局部中的变量，只能访问被final修饰的局部变量</p>
<p>成员修饰符(Static,private…)只能修饰成员变量</p>
<p>匿名内部类：</p>
<p>前提，内部类必须是继承一个类或者实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Absdemo</span>&#123;    </span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">			...</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Absdemo</span>()<span class="comment">//这是一个Absdemo的一个匿名子类对象</span></span><br><span class="line">							&#123;</span><br><span class="line">			<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;匿名内部类！&quot;</span>)；</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;.show();</span><br><span class="line">				&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式：new 父类或者接口(){定义子类内容}；</p>
<p>其实匿名内部类是一个匿名子类对象，而且这个对象是带有内容的</p>
<p>匿名内部类中定义的方法最好不要超过3个(方法比较多的话就直接创建一个有名字的子类)</p>
<p>内部类参考: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9scGhpbjA1MjAvcC8zODExNDQ1Lmh0bWw=">https://www.cnblogs.com/dolphin0520/p/3811445.html<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="Java常用类——Object的通用方法"><a href="#Java常用类——Object的通用方法" class="headerlink" title="Java常用类——Object的通用方法"></a>Java常用类——Object的通用方法</h1><p>Java类层次结构的顶层是<code>Object</code>类，所有的其他类都隐式的继承于它。因此，所有的类也都从<code>Object</code>中继承了方法，其中最重要的几个方法如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>protected Object clone()</code></td>
<td>创建并返回当前对象的一份拷贝</td>
</tr>
<tr>
<td><code>protected void finalize()</code></td>
<td>当垃圾回收器判断出该对象不再被引用时，就会调用finalize()方法。在<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDM5MDI0Nw==">对象的创建与销毁<i class="fa fa-external-link-alt"></i></span>中有对finalizers的介绍。</td>
</tr>
<tr>
<td><code>boolean equals(Object obj)</code></td>
<td>判断另外一个对象是否与当前对象相等</td>
</tr>
<tr>
<td><code>int hasCode()</code></td>
<td>返回当前对象的哈希值</td>
</tr>
<tr>
<td><code>String toString()</code></td>
<td>返回一个表示当前对象的字符串</td>
</tr>
<tr>
<td><code>void notify()</code></td>
<td>唤醒一个等待当前对象的锁监视器的线程。我们将会在第9篇文章并发最佳实践中详细介绍此方法</td>
</tr>
<tr>
<td><code>void notifyAll()</code></td>
<td>唤醒所有等待当前对象的锁监视器的线程。我们将会在第9篇文章并发最佳实践中详细介绍此方法</td>
</tr>
<tr>
<td><code>void wait()</code> <code>void wait(long timeout)</code> <code>void wait(long timeout, int nanos)</code></td>
<td>使当前线程进入等待状态直到其他线程调用了当前对象的<code>notify()</code>或<code>notifyAll()</code>方法。我们将会在第9篇文章并发最佳实践中详细介绍此方法</td>
</tr>
</tbody></table>
<p>表1</p>
<p>重点介绍<code>equals</code>、<code>hashCode</code>、<code>toString</code>和<code>clone</code>方法。</p>
<h2 id="equlas和hashCode方法"><a href="#equlas和hashCode方法" class="headerlink" title="equlas和hashCode方法"></a>equlas和hashCode方法</h2><p>默认情况下，Java 中任何两个对象引用(或类实例引用)只有指向相同的内存地址时才认为是相等的(引用相等)。但是Java允许通过重载<code>Object</code>的<code>equals()</code>方法给类自定义判等规则。听起来这是个很强大的概念，然而在适当的<code>equals()</code>方法实现需要满足以下几个规则限制：</p>
<ul>
<li>自反性：对象x必须与其自身相等，equals(x)返回true</li>
<li>对称性：如果equals(y)为true，则y.equals(x)也要返回true</li>
<li>传递性：如果equals(y)为true，并且y.equals(z)也为true，则x.equals(z)也要为true</li>
<li>一致性：多次调用equals()方法应该返回相同值，除非对用于判等的任何一个属性进行了修改</li>
<li>与null判等：equals(null)总是要返回false</li>
</ul>
<p>不幸的是Java编译器并不会在编译时对以上规则进行检查。然而，不遵守上述规则时可能会引入非常怪异并难以解决的问题。通用的建议是：如果需要重写<code>equals()</code>方法，请至少思考两次重写的必要性。遵循以上规则，我们为<code>Person</code>类重写一个简单的<code>equals()</code>实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javacodegeeks.advanced.objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">( <span class="keyword">final</span> String firstName, <span class="keyword">final</span> String lastName, <span class="keyword">final</span> String email )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 0: Please add the @Override annotation, it will ensure that your</span></span><br><span class="line">    <span class="comment">// intention is to change the default implementation.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">( Object obj )</span> &#123;</span><br><span class="line">        <span class="comment">// Step 1: Check if the &#x27;obj&#x27; is null</span></span><br><span class="line">        <span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step 2: Check if the &#x27;obj&#x27; is pointing to the this instance</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">this</span> == obj ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step 3: Check classes equality. Note of caution here: please do not use the </span></span><br><span class="line">        <span class="comment">// &#x27;instanceof&#x27; operator unless class is declared as final. It may cause </span></span><br><span class="line">        <span class="comment">// an issues within class hierarchies.</span></span><br><span class="line">        <span class="keyword">if</span> ( getClass() != obj.getClass() ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step 4: Check individual fields equality</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> ( email == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( other.email != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( !email.equals( other.email ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( firstName == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( other.firstName != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !firstName.equals( other.firstName ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ( lastName == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( other.lastName != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !lastName.equals( other.lastName ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此部分介绍<code>hashCode()</code>方法并不是偶然的，至少要记住下面这条规则：任何时候重载<code>equals()</code>方法时，需要一并重载<code>hashCode()</code>方法。如果两个对象通过<code>equals()</code>方法判等时返回true，则每个对象的<code>hashCode()</code>方法需要返回相同的整数值（反过来并没有限制：如果两个对象通过<code>equals()</code>方法返回false，则<code>hashCode()</code>方法可以返回相同或不同的整数值）。下面看一下<code>Person</code>类的<code>hashCode()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Please add the @Override annotation, it will ensure that your</span></span><br><span class="line"><span class="comment">// intention is to change the default implementation.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    result = prime * result + ( ( email == <span class="literal">null</span> ) ? <span class="number">0</span> : email.hashCode() );</span><br><span class="line">    result = prime * result + ( ( firstName == <span class="literal">null</span> ) ? <span class="number">0</span> : firstName.hashCode() );</span><br><span class="line">    result = prime * result + ( ( lastName == <span class="literal">null</span> ) ? <span class="number">0</span> : lastName.hashCode() );</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p>为了避免得到不可预期的结果，尽可能在实现<code>equals()</code>和<code>hashCode()</code>方法时使用<code>final</code>字段，从而保证方法的结果不会受到字段变化的影响(尽管真实场景中未必发生)。</p>
<p>最后，要确保在实现<code>equals()</code>和<code>hashCode()</code>方法是使用相同的字段，以确保在不可预期的字段调整时保证这两个方法行为的一致性。</p>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p><code>toString()</code>是最让人感兴趣的方法，并且被重载的频率也更高。此方法的目的是提供对象(类实例)的字符串表现。如果对<code>toString()</code>方法重载恰当，能极大的简化debug难度和分析解决问题的过程。</p>
<p>默认情况下，<code>toString()</code>的结果仅仅返回以<code>@</code>符分隔的全类名与对象哈希值串，然而这个结果在大多场景下并没什么用途。如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">com<span class="selector-class">.javacodegeeks</span><span class="selector-class">.advanced</span><span class="selector-class">.objects</span>.Person@<span class="number">6104</span>e2ee</span><br></pre></td></tr></table></figure>

<p>我们来通过重写Person和<code>toString()</code>方法以使其输出更有用，下面是其中一种实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Please add the @Override annotation, it will ensure that your</span></span><br><span class="line"><span class="comment">// intention is to change the default implementation.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format( <span class="string">&quot;%s[email=%s, first name=%s, last name=%s]&quot;</span>, </span><br><span class="line">        getClass().getSimpleName(), email, firstName, lastName );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在<code>toString()</code>方法中包含了Person的所有字段，然后执行下面的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;john.smith@domain.com&quot;</span> );</span><br><span class="line">System.out.println( person.toString() );</span><br></pre></td></tr></table></figure>

<p>控制台中将输出以下结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[email=john.smith<span class="meta">@domain</span>.com, first name=John, last name=Smith]</span><br></pre></td></tr></table></figure>

<p>遗憾的是在Java标准库中对<code>toString()</code>方法实现的支持有限，不过还是有几个有用的方法：<code>Objects.toString()</code>, <code>Arrays.toString() / Arrays.deepToString()</code>。下面看一下<code>Office</code>类以及其<code>toString()</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javacodegeeks.advanced.objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Office</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person[] persons;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Office</span><span class="params">( Person ... persons )</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.persons = Arrays.copyOf( persons, persons.length );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format( <span class="string">&quot;%s&#123;persons=%s&#125;&quot;</span>, </span><br><span class="line">            getClass().getSimpleName(), Arrays.toString( persons ) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person[] getPersons() &#123;</span><br><span class="line">        <span class="keyword">return</span> persons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的控制台输出如下(同时也有<code>Person</code>实例的字符串值)：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Office&#123;persons=[Person[<span class="attribute">email</span>=john.smith@domain.com, first <span class="attribute">name</span>=John, last <span class="attribute">name</span>=Smith]]&#125;</span><br></pre></td></tr></table></figure>

<p>Java社区实例了大量有用的类库以简化<code>toString()</code>的实现。其中广泛使用的有<code>Google Guava</code>的<span class="exturl" data-url="aHR0cDovL2RvY3MuZ3VhdmEtbGlicmFyaWVzLmdvb2dsZWNvZGUuY29tL2dpdC9qYXZhZG9jL2NvbS9nb29nbGUvY29tbW9uL2Jhc2UvT2JqZWN0cy5Ub1N0cmluZ0hlbHBlci5odG1s">Objects.toStringHelper<i class="fa fa-external-link-alt"></i></span>和<code>Apache Commons Lang</code>的<span class="exturl" data-url="aHR0cDovL2NvbW1vbnMuYXBhY2hlLm9yZy9wcm9wZXIvY29tbW9ucy1sYW5nL2FwaWRvY3Mvb3JnL2FwYWNoZS9jb21tb25zL2xhbmczL2J1aWxkZXIvVG9TdHJpbmdCdWlsZGVyLmh0bWw=">ToStringBuilder<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><p>如果举出Java中最声名狼藉的方法，当属<code>clone()</code>无疑。<code>clone()</code>方法的目的很简单——返回对象实例的拷贝，然而有一堆理由可证明其使用并不像听起来那么轻而易举。</p>
<p>首先，实现自定义的<code>clone()</code>方法时需要遵守<span class="exturl" data-url="aHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNy9kb2NzL2FwaS9qYXZhL2xhbmcvT2JqZWN0Lmh0bWwjY2xvbmUoKQ==">Java文档<i class="fa fa-external-link-alt"></i></span>中列出的一系列约定。其次，在<code>Object</code>类中<code>clone()</code>方法被声明为<code>protected</code>，所以为了提高方法的可见性，在重载时需要声明为<code>public</code>并把返回值类型调整为重载类自身类型。再次，重载类需要实现<code>Cloneable</code>接口(尽管该接口作为一种声明，并未提供任何方法定义)，否则将会抛出<code>CloneNotSupportedException</code>异常。最后，在实现<code>clone()</code>方法时要先调用<code>super.clone()</code>然后再执行其他需要的动作。下面看一下<code>Person</code>类中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// Please add the @Override annotation, it will ensure that your</span></span><br><span class="line">    <span class="comment">// intention is to change the default implementation.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> ( Person )<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现看起来简单直接，然而却隐藏着错误。当类实例的clone动作被执行时，未调用任何构造方法，后果将导致预料外的数据泄露。下面再看下<code>Office</code>类中的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javacodegeeks.advanced.objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Office</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person[] persons;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Office</span><span class="params">( Person ... persons )</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.persons = Arrays.copyOf( persons, persons.length );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Office <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> ( Office )<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person[] getPersons() &#123;</span><br><span class="line">        <span class="keyword">return</span> persons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实现中，<code>Office</code>实例克隆出来的所有对象都将共享相同的person数组，然而这并不是我们预期的行为。为了让<code>clone()</code>实现正确的行为，我们还要做一些额外的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Office <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Office</span> <span class="variable">clone</span> <span class="operator">=</span> ( Office )<span class="built_in">super</span>.clone();</span><br><span class="line">    clone.persons = persons.clone();</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来是正确了，但如果对persons字段声明为<code>final</code>就将破坏这种正确性，因此<code>final</code>字段不能被重新赋值，从而导致数据再次被共享。</p>
<p>总之，当需要类实例的拷贝时，尽可能避免使用<code>clone()</code> &#x2F; <code>Cloneable</code>，相反可以选择其他更简单的替代方案(例如：C++程序员熟悉的复制构造方法，或者工厂方法——在<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDM5MDI0Nw==">对象的创建与销毁<i class="fa fa-external-link-alt"></i></span>中讨论过的一种有用的构造模式)。</p>
<h2 id="equals方法与”-”操作符"><a href="#equals方法与”-”操作符" class="headerlink" title="equals方法与”&#x3D;&#x3D;”操作符"></a>equals方法与”&#x3D;&#x3D;”操作符</h2><p>在Java中，<code>==</code>操作符与equals()方法有种奇怪的关系，却会引入大量的问题与困惑。大多数情况下(除比较基本数据类型)，&#x3D;&#x3D;操作符执行的是引用相等：只要两个引用指向同一个对象时为true，否则返回false。下面举例说明二者的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>( <span class="string">&quot;bbb&quot;</span> );</span><br><span class="line">System.out.println( <span class="string">&quot;Using == operator: &quot;</span> + ( str1 == <span class="string">&quot;bbb&quot;</span> ) );</span><br><span class="line">System.out.println( <span class="string">&quot;Using equals() method: &quot;</span> + str1.equals( <span class="string">&quot;bbb&quot;</span> ) );</span><br></pre></td></tr></table></figure>

<p>从我们人类的视角来看，str1 &#x3D;&#x3D; “bbb” 和 str1.equals(“bbb”)并无区别：str1仅仅是”bbb”的一个引用，所以结果应该是相同的；但对于Java来说却不尽然：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Using</span> == <span class="keyword">operator</span>: <span class="keyword">false</span></span><br><span class="line"><span class="keyword">Using</span> <span class="keyword">equals</span>() <span class="keyword">method</span>: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>尽管两个字符串看起来完全一样，但事实上却是两个不同的<code>String</code>实例。作为建议，在处理对象引用时要使用<code>equals()</code>或<code>Objects.equals()</code>进行判等，除非你真的是要判断两个引用是否指向同一个实例。</p>
<h2 id="有用的帮助类"><a href="#有用的帮助类" class="headerlink" title="有用的帮助类"></a>有用的帮助类</h2><p>从Java 7发布以来，一批有用的帮助类加入到了标准Java库中，<code>Objects</code>便是其中之一。具体来说，以下三个方法可以简化你的<code>equals()</code>和<code>hashCode()</code>方法实现。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>static boolean equals(Object a, Object b)</code></td>
<td>当参数中的两个对象相等时返回true，否则返回false</td>
</tr>
<tr>
<td><code>static int hash(Object...values)</code></td>
<td>为参数列表生成哈希值</td>
</tr>
<tr>
<td><code>static int hashCode(Object o)</code></td>
<td>为非null参数生成哈希值，如果参数为null返回0</td>
</tr>
</tbody></table>
<p>如果使用上面的方法来重写<code>Person</code>的<code>equals()</code>和<code>hashCode()</code>实现，代码量将会大大缩减，同时代码的可读性也将大大增强。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">( Object obj )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">this</span> == obj ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ( getClass() != obj.getClass() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">final</span> <span class="type">PersonObjects</span> <span class="variable">other</span> <span class="operator">=</span> (PersonObjects) obj;</span><br><span class="line">    <span class="keyword">if</span>( !Objects.equals( email, other.email ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( !Objects.equals( firstName, other.firstName ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( !Objects.equals( lastName, other.lastName ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash( email, firstName, lastName );</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<h1 id="Java-API-——StringBuffer类"><a href="#Java-API-——StringBuffer类" class="headerlink" title="Java API ——StringBuffer类"></a>Java API ——StringBuffer类</h1><h2 id="StringBuffer类概述"><a href="#StringBuffer类概述" class="headerlink" title="StringBuffer类概述"></a>StringBuffer类概述</h2><p>　　1）我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题</p>
<p>　　2）线程安全的可变字符序列</p>
<p>　　3）StringBuffer和String的区别</p>
<p>　　　　· 前者长度和内容可变，后者不可变。</p>
<p>​        　 · 如果使用前者做字符串的拼接，不会浪费太多的资源。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>​     StringBuffer 方法</p>
<p>以下是 StringBuffer 类支持的主要方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>public StringBuffer append(String s)将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td>2</td>
<td>public StringBuffer reverse() 将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td>3</td>
<td>public delete(int start, int end)移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td>4</td>
<td>public insert(int offset, int i)将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td>5</td>
<td>replace(int start, int end, String str)使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody></table>
<p>下面的列表里的方法和 String 类的方法类似：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>int capacity()返回当前容量。</td>
</tr>
<tr>
<td>2</td>
<td>char charAt(int index)返回此序列中指定索引处的 <code>char</code> 值。</td>
</tr>
<tr>
<td>3</td>
<td>void ensureCapacity(int minimumCapacity)确保容量至少等于指定的最小值。</td>
</tr>
<tr>
<td>4</td>
<td>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此序列复制到目标字符数组 <code>dst</code>。</td>
</tr>
<tr>
<td>5</td>
<td>int indexOf(String str)返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td>6</td>
<td>int indexOf(String str, int fromIndex)从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td>7</td>
<td>int lastIndexOf(String str)返回最右边出现的指定子字符串在此字符串中的索引。</td>
</tr>
<tr>
<td>8</td>
<td>int lastIndexOf(String str, int fromIndex)返回 String 对象中子字符串最后出现的位置。</td>
</tr>
<tr>
<td>9</td>
<td>int length() 返回长度（字符数）。</td>
</tr>
<tr>
<td>10</td>
<td>void setCharAt(int index, char ch)将给定索引处的字符设置为 <code>ch</code>。</td>
</tr>
<tr>
<td>11</td>
<td>void setLength(int newLength)设置字符序列的长度。</td>
</tr>
<tr>
<td>12</td>
<td>CharSequence subSequence(int start, int end)返回一个新的字符序列，该字符序列是此序列的子序列。</td>
</tr>
<tr>
<td>13</td>
<td>String substring(int start)返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td>14</td>
<td>String substring(int start, int end)返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td>15</td>
<td>String toString()返回此序列中数据的字符串表示形式。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// public StringBuffer():无参构造方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb.capacity:&quot;</span>+sb.capacity()); <span class="comment">//16</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb.length:&quot;</span>+sb.length()); <span class="comment">//0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// public StringBuffer(int capacity):指定容量的字符串缓冲区对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2.capacity:&quot;</span>+sb2.capacity()); <span class="comment">//50</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb2.length:&quot;</span>+sb2.length()); <span class="comment">//0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// public StringBuffer(String str):指定字符串内容的字符串缓冲区对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb3:&quot;</span>+sb3); <span class="comment">//&quot;hello&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb3.capacity:&quot;</span>+sb3.capacity()); <span class="comment">//21</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb3.length:&quot;</span>+sb3.length());<span class="comment">//5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意返回值，可以查看源码，默认空间是16。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">     * Constructs a string buffer with no characters in it and an</span><br><span class="line">     * initial capacity of <span class="number">16</span> characters.</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    /</span><br><span class="line">     * Constructs a string buffer with no characters in it and</span><br><span class="line">     * the specified initial capacity.</span><br><span class="line">     *</span><br><span class="line">     * <span class="meta">@param</span>      capacity  the initial capacity.</span><br><span class="line">     * <span class="meta">@exception</span>  NegativeArraySizeException  <span class="keyword">if</span> the &lt;code&gt;capacity&lt;/code&gt;</span><br><span class="line">     *               argument is less than &lt;code&gt;<span class="number">0</span>&lt;/code&gt;.</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    /</span><br><span class="line">     * Constructs a string buffer initialized to the contents of the</span><br><span class="line">     * specified string. The initial capacity of the string buffer is</span><br><span class="line">     * &lt;code&gt;<span class="number">16</span>&lt;/code&gt; plus the length of the string argument.</span><br><span class="line">     *</span><br><span class="line">     * <span class="meta">@param</span>   str   the initial contents of the buffer.</span><br><span class="line">     * <span class="meta">@exception</span> NullPointerException <span class="keyword">if</span> &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;<span class="literal">null</span>&lt;/code&gt;</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="StringBuffer类的成员方法"><a href="#StringBuffer类的成员方法" class="headerlink" title="StringBuffer类的成员方法"></a>StringBuffer类的成员方法</h2><h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><p>​            · public StringBuffer append(String str)：可以把任意类型数据添加到字符串缓冲区里面，并返回字符串缓冲区本身</p>
<p>​            · public StringBuffer insert(int offset,String str)：在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字符串缓冲区对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//返回对象本身</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2); <span class="comment">//sb2:hello</span></span><br><span class="line">        System.out.println(sb == sb2); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//一步一步的添加数据</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb3.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        sb3.append(<span class="literal">true</span>);</span><br><span class="line">        sb3.append(<span class="number">12</span>);</span><br><span class="line">        sb3.append(<span class="number">34.56</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb3:&quot;</span>+sb3); <span class="comment">//sb3:hellotrue1234.56</span></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb4.append(<span class="string">&quot;hello&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">12</span>).append(<span class="number">34.56</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb4:&quot;</span>+sb4); <span class="comment">//sb4:hellotrue1234.56</span></span><br><span class="line">        <span class="comment">//StringBuffer insert(int offset,Stringstr):插入数据</span></span><br><span class="line">        sb3.insert(<span class="number">5</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb3:&quot;</span>+sb3); <span class="comment">//sb3:hellohellotrue1234.56</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h3><p>​            · public StringBuffer deleteCharAt(int index)：删除指定位置的字符，并返回本身</p>
<p>​            · public StringBuffer delete(int start,int end)：删除从指定位置开始指定位置结束的内容，并返回本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        sb1.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb1:&quot;</span>+sb1); <span class="comment">//sb1:helloworldjava</span></span><br><span class="line">        <span class="comment">// public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身</span></span><br><span class="line">        <span class="comment">// 需求：我要删除e这个字符</span></span><br><span class="line">        sb1.deleteCharAt(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 需求:我要删除第一个l这个字符</span></span><br><span class="line">        sb1.deleteCharAt(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb1:&quot;</span>+sb1);  <span class="comment">//sb1:hloworldjava</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        <span class="comment">// public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello World Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2); <span class="comment">//sb2:Hello World Java</span></span><br><span class="line">        <span class="comment">// 需求：我要删除World这个字符串</span></span><br><span class="line">        sb2.delete(<span class="number">5</span>,<span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2); <span class="comment">//sb2:Hello Java</span></span><br><span class="line">        <span class="comment">// 需求:我要删除所有的数据</span></span><br><span class="line">        sb2.delete(<span class="number">0</span>, sb2.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2); <span class="comment">//sb2:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="替换功能"><a href="#替换功能" class="headerlink" title="替换功能"></a>替换功能</h3><p>​            · public StringBuffer replace(int start,int end,String str)：使用给定String中的字符替换词序列的子字符串中的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字符串缓冲区对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span> + sb); <span class="comment">//sb:helloworldjava</span></span><br><span class="line">        <span class="comment">// public StringBuffer replace(int start,int end,String str):从start开始到end用str替换</span></span><br><span class="line">        <span class="comment">// 需求：我要把world这个数据替换为&quot;节日快乐&quot;</span></span><br><span class="line">        sb.replace(<span class="number">5</span>,<span class="number">10</span>,<span class="string">&quot;节日快乐&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:hello节日快乐java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转功能"><a href="#反转功能" class="headerlink" title="反转功能"></a>反转功能</h3><p>​            · public StringBuffer reverse()：将此字符序列用其反转形式取代，返回对象本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建字符串缓冲区对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//添加数据</span></span><br><span class="line">        sb.append(<span class="string">&quot;林青霞爱我&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:林青霞爱我</span></span><br><span class="line">        <span class="comment">//public StringBuffer reverse()</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:我爱霞青林</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="截取功能"><a href="#截取功能" class="headerlink" title="截取功能"></a>截取功能</h3><p>​            · public String substring(int start)：返回一个新的String，它包含此字符序列当前所包含的字符子序列</p>
<p>​            · public String substring(int start,int end)：返回一个新的String，它包含此序列当前所包含的字符子序列</p>
<p>​        注意：截取功能和前面几个功能的不同</p>
<p>​            · 返回值类型是String类型，本身没有发生改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建字符串缓冲区对象</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:helloworldjava</span></span><br><span class="line">        <span class="comment">//截取功能</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.substring(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span>+s); <span class="comment">//s:worldjava</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:helloworldjava</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> sb.substring(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ss:&quot;</span>+ss); <span class="comment">//ss:world</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:helloworldjava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="String与StringBuffer的相互转换"><a href="#String与StringBuffer的相互转换" class="headerlink" title="String与StringBuffer的相互转换"></a>String与StringBuffer的相互转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//String --&gt; StringBuffer</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 注意：不能把字符串的值直接赋值给StringBuffer</span></span><br><span class="line">        <span class="comment">// StringBuffer sb = &quot;hello&quot;;</span></span><br><span class="line">        <span class="comment">// StringBuffer sb = s;</span></span><br><span class="line">        <span class="comment">//方式一：通过构造方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line">        <span class="comment">//方式二：通过append方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb2.append(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb:&quot;</span>+sb); <span class="comment">//sb:hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb2:&quot;</span>+sb2); <span class="comment">//sb2:hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//StringBuffer --&gt; String</span></span><br><span class="line">         <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//方式一：通过构造方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer);</span><br><span class="line">        <span class="comment">//方式二：通过toString()方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> buffer.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;str:&quot;</span>+str); <span class="comment">//str:java</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str2:&quot;</span>+str2); <span class="comment">//str2:java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="把数组拼接成一个字符串"><a href="#把数组拼接成一个字符串" class="headerlink" title="把数组拼接成一个字符串"></a>把数组拼接成一个字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">44</span>,<span class="number">33</span>,<span class="number">55</span>,<span class="number">11</span>,<span class="number">22</span>&#125;;</span><br><span class="line">        <span class="comment">//定义功能</span></span><br><span class="line">        <span class="comment">//方式一：用String做拼接的方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result1</span> <span class="operator">=</span> arrayToString1(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;result1:&quot;</span>+result1); <span class="comment">//result1:[44,33,55,11,22]</span></span><br><span class="line">        <span class="comment">//方式二：用StringBuffer做拼接的方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> arrayToString2(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;result2:&quot;</span>+result2); <span class="comment">//result2:[44,33,55,11,22]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrayToString1</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">                s += arr[x];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s += arr[x];</span><br><span class="line">                s += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrayToString2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(arr[x]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(arr[x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="把字符串反转"><a href="#把字符串反转" class="headerlink" title="把字符串反转"></a>把字符串反转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;I love Java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result1</span> <span class="operator">=</span> myReverse1(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;result1:&quot;</span>+result1); <span class="comment">//result1:avaJ evol I</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> myReverse2(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;result2:&quot;</span>+result2); <span class="comment">//result2:avaJ evol I</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">myReverse1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> s.length()-<span class="number">1</span>; x &gt;= <span class="number">0</span>; x--)&#123;</span><br><span class="line">            result += ch[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">myReverse2</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="判断一个字符串是否是对称的"><a href="#判断一个字符串是否是对称的" class="headerlink" title="判断一个字符串是否是对称的"></a>判断一个字符串是否是对称的</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();  <span class="comment">//abcba</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> isSymmertrical1(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;result1:&quot;</span>+result1); <span class="comment">//result1:true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> isSymmertrical2(str); <span class="comment">//result2:true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result2:&quot;</span>+result2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmertrical1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span> ch[] = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = ch.length-<span class="number">1</span>; start &lt;= end;start++,end--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[start] != ch[end])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmertrical2</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).reverse().toString().equals(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="了解一下StringBuilder类"><a href="#了解一下StringBuilder类" class="headerlink" title="了解一下StringBuilder类"></a>了解一下StringBuilder类</h2><p>​        一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的 API，但不保证同步。该类被设计用作 <code>StringBuffer</code> 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 <code>StringBuffer</code> 要快。</p>
<p>​        只要将StringBuffer的功能替换到StringBuilder就可以了。</p>
<h2 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String,StringBuffer,StringBuilder的区别"></a>String,StringBuffer,StringBuilder的区别</h2><p>　　1）String是内容不可变的，而StringBuffer,StringBuilder都是内容可变的。</p>
<p>　　2）StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高</p>
<p>10、StringBuffer和数组的区别？</p>
<p>​            A：二者都可以看出是一个容器，装其他的数据。</p>
<p>​            B：但是呢，StringBuffer的数据最终是一个字符串数据。</p>
<p>​            C：而数组可以放置多种数据，但必须是同一种数据类型的。</p>
<p>11、</p>
<p>​        A：String作为参数传递</p>
<p>​        B：StringBuffer作为参数传递</p>
<p>​        形式参数：</p>
<p>　　　　　　基本类型：形式参数的改变不影响实际参数</p>
<p>　　　　　　引用类型：形式参数的改变直接影响实际参数</p>
<p>​        注意：</p>
<p>　　　　String作为参数传递，效果和基本类型作为参数传递是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(s1 + <span class="string">&quot;---&quot;</span> + s2);<span class="comment">//hello---world</span></span><br><span class="line">        change(s1, s2);</span><br><span class="line">        System.out.println(s1 + <span class="string">&quot;---&quot;</span> + s2);<span class="comment">//hello---world</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(sb1 + <span class="string">&quot;---&quot;</span> + sb2);<span class="comment">//hello---world</span></span><br><span class="line">        change(sb1, sb2);</span><br><span class="line">        System.out.println(sb1 + <span class="string">&quot;---&quot;</span> + sb2);<span class="comment">//hello---worldworld</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Stringz作为形参传递不会改变实参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        s1 = s2;</span><br><span class="line">        s2 = s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//StringBuffer作为形参，如果直接赋值则不会影响实参，但是如果是使用方法改变形参则会影响实参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(StringBuffer sb1, StringBuffer sb2)</span> &#123;</span><br><span class="line">        sb1 = sb2;</span><br><span class="line">        sb2.append(sb1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-常用类——String类"><a href="#Java-常用类——String类" class="headerlink" title="Java 常用类——String类"></a>Java 常用类——String类</h1><p>String类在java.lang包中，java使用String类创建一个字符串变量，字符串变量属于对象。java把String类声明的final类，不能有类。String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。</p>
<p>下面是 String 类支持的方法，更多详细，参看 <span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL21hbnVhbC9qZGsxLjYvamF2YS9sYW5nL1N0cmluZy5odG1s">Java String API<i class="fa fa-external-link-alt"></i></span> 文档:</p>
<table>
<thead>
<tr>
<th>SN(序号)</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY2hhcmF0Lmh0bWw=">char charAt(int index)<i class="fa fa-external-link-alt"></i></span>返回指定索引处的 char 值。</td>
</tr>
<tr>
<td>2</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29tcGFyZXRvLmh0bWw=">int compareTo(Object o)<i class="fa fa-external-link-alt"></i></span>把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td>3</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29tcGFyZXRvLmh0bWw=">int compareTo(String anotherString)<i class="fa fa-external-link-alt"></i></span>按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td>4</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29tcGFyZXRvaWdub3JlY2FzZS5odG1s">int compareToIgnoreCase(String str)<i class="fa fa-external-link-alt"></i></span>按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td>5</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29uY2F0Lmh0bWw=">String concat(String str)<i class="fa fa-external-link-alt"></i></span>将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td>6</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29udGVudGVxdWFscy5odG1s">boolean contentEquals(StringBuffer sb)<i class="fa fa-external-link-alt"></i></span>当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td>7</td>
<td>[static String copyValueOf(char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29weXZhbHVlb2YuaHRtbA==">] data)<i class="fa fa-external-link-alt"></i></span>返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td>8</td>
<td>[static String copyValueOf(char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctY29weXZhbHVlb2YuaHRtbA==">] data, int offset, int count)<i class="fa fa-external-link-alt"></i></span>返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td>9</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZW5kc3dpdGguaHRtbA==">boolean endsWith(String suffix)<i class="fa fa-external-link-alt"></i></span>测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td>10</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZXF1YWxzLmh0bWw=">boolean equals(Object anObject)<i class="fa fa-external-link-alt"></i></span>将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td>11</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZXF1YWxzaWdub3JlY2FzZS5odG1s">boolean equalsIgnoreCase(String anotherString)<i class="fa fa-external-link-alt"></i></span>将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td>12</td>
<td>[byte<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZ2V0Ynl0ZXMuaHRtbA==">] getBytes()<i class="fa fa-external-link-alt"></i></span> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td>13</td>
<td>[byte<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZ2V0Ynl0ZXMuaHRtbA==">] getBytes(String charsetName)<i class="fa fa-external-link-alt"></i></span>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td>14</td>
<td>[void getChars(int srcBegin, int srcEnd, char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctZ2V0Y2hhcnMuaHRtbA==">] dst, int dstBegin)<i class="fa fa-external-link-alt"></i></span>将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td>15</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaGFzaGNvZGUuaHRtbA==">int hashCode()<i class="fa fa-external-link-alt"></i></span>返回此字符串的哈希码。</td>
</tr>
<tr>
<td>16</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(int ch)<i class="fa fa-external-link-alt"></i></span>返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td>17</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(int ch, int fromIndex)<i class="fa fa-external-link-alt"></i></span>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td>18</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(String str)<i class="fa fa-external-link-alt"></i></span> 返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td>19</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW5kZXhvZi5odG1s">int indexOf(String str, int fromIndex)<i class="fa fa-external-link-alt"></i></span>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td>20</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctaW50ZXJuLmh0bWw=">String intern()<i class="fa fa-external-link-alt"></i></span> 返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td>21</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(int ch)<i class="fa fa-external-link-alt"></i></span> 返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td>22</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(int ch, int fromIndex)<i class="fa fa-external-link-alt"></i></span>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td>23</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(String str)<i class="fa fa-external-link-alt"></i></span>返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td>24</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGFzdGluZGV4b2YuaHRtbA==">int lastIndexOf(String str, int fromIndex)<i class="fa fa-external-link-alt"></i></span> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td>25</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbGVuZ3RoLmh0bWw=">int length()<i class="fa fa-external-link-alt"></i></span>返回此字符串的长度。</td>
</tr>
<tr>
<td>26</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctbWF0Y2hlcy5odG1s">boolean matches(String regex)<i class="fa fa-external-link-alt"></i></span>告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td>27</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVnaW9ubWF0Y2hlcy5odG1s">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<i class="fa fa-external-link-alt"></i></span>测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td>28</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVnaW9ubWF0Y2hlcy5odG1s">boolean regionMatches(int toffset, String other, int ooffset, int len)<i class="fa fa-external-link-alt"></i></span>测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td>29</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVwbGFjZS5odG1s">String replace(char oldChar, char newChar)<i class="fa fa-external-link-alt"></i></span>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td>30</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVwbGFjZWFsbC5odG1s">String replaceAll(String regex, String replacement<i class="fa fa-external-link-alt"></i></span>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td>31</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctcmVwbGFjZWZpcnN0Lmh0bWw=">String replaceFirst(String regex, String replacement)<i class="fa fa-external-link-alt"></i></span> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td>32</td>
<td>[String<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3BsaXQuaHRtbA==">] split(String regex)<i class="fa fa-external-link-alt"></i></span>根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td>33</td>
<td>[String<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3BsaXQuaHRtbA==">] split(String regex, int limit)<i class="fa fa-external-link-alt"></i></span>根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td>34</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3RhcnRzd2l0aC5odG1s">boolean startsWith(String prefix)<i class="fa fa-external-link-alt"></i></span>测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td>35</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3RhcnRzd2l0aC5odG1s">boolean startsWith(String prefix, int toffset)<i class="fa fa-external-link-alt"></i></span>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td>36</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3Vic2VxdWVuY2UuaHRtbA==">CharSequence subSequence(int beginIndex, int endIndex)<i class="fa fa-external-link-alt"></i></span> 返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td>37</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3Vic3RyaW5nLmh0bWw=">String substring(int beginIndex)<i class="fa fa-external-link-alt"></i></span>返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td>38</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctc3Vic3RyaW5nLmh0bWw=">String substring(int beginIndex, int endIndex)<i class="fa fa-external-link-alt"></i></span>返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td>39</td>
<td>[char<span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9jaGFyYXJyYXkuaHRtbA==">] toCharArray()<i class="fa fa-external-link-alt"></i></span>将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td>40</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9sb3dlcmNhc2UuaHRtbA==">String toLowerCase()<i class="fa fa-external-link-alt"></i></span>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td>41</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9sb3dlcmNhc2UuaHRtbA==">String toLowerCase(Locale locale)<i class="fa fa-external-link-alt"></i></span> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td>42</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG9zdHJpbmcuaHRtbA==">String toString()<i class="fa fa-external-link-alt"></i></span> 返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td>43</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG91cHBlcmNhc2UuaHRtbA==">String toUpperCase()<i class="fa fa-external-link-alt"></i></span>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td>44</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdG91cHBlcmNhc2UuaHRtbA==">String toUpperCase(Locale locale)<i class="fa fa-external-link-alt"></i></span>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td>45</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdHJpbS5odG1s">String trim()<i class="fa fa-external-link-alt"></i></span>返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td>46</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1zdHJpbmctdmFsdWVvZi5odG1s">static String valueOf(primitive data type x)<i class="fa fa-external-link-alt"></i></span>返回给定data type类型x参数的字符串表示形式。</td>
</tr>
</tbody></table>
<h2 id="String类对象的创建"><a href="#String类对象的创建" class="headerlink" title="String类对象的创建"></a>String类对象的创建</h2><p>字符串声明：String stringName;<br>字符串创建：stringName &#x3D; new String(字符串常量);或stringName &#x3D; 字符串常量;</p>
<h2 id="String类构造方法"><a href="#String类构造方法" class="headerlink" title="String类构造方法"></a>String类构造方法</h2><ol>
<li>public String()</li>
</ol>
<p>无参构造方法，用来创建空字符串的String对象。<br> 1 String str1 &#x3D; new String();<br>2. public String(String value)<br>用已知的字符串value创建一个String对象。<br> 1 String str2 &#x3D; new String(“asdf”); 2 String str3 &#x3D; new String(str2);<br>3. public String(char[] value)<br>用字符数组value创建一个String对象。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>char[] value = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line"><span class="symbol">2 </span>String str4 = <span class="keyword">new</span> String(value);//相当于String str4 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>public String(char chars[], int startIndex, int numChars)<br>用字符数组chars的startIndex开始的numChars个字符创建一个String对象。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>char[] value = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line"><span class="symbol">2 </span>String str5 = <span class="keyword">new</span> String(value, <span class="number">1</span>, <span class="number">2</span>);//相当于String str5 = <span class="keyword">new</span> String(<span class="string">&quot;bc&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>public String(byte[] values)<br>用比特数组values创建一个String对象。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>byte[] strb = <span class="keyword">new</span> byte[]&#123;<span class="number">65</span>,<span class="number">66</span>&#125;;</span><br><span class="line"><span class="symbol">2 </span>String str6 = <span class="keyword">new</span> String(strb);//相当于String str6 = <span class="keyword">new</span> String(<span class="string">&quot;AB&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h2><ol>
<li>求字符串长度<br>public int length()&#x2F;&#x2F;返回该字符串的长度</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="keyword">new</span> String(<span class="string">&quot;asdfzxc&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span><span class="keyword">int</span> strlength = str.length();//strlength = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>求字符串某一位置字符<br>public char charAt(int index)&#x2F;&#x2F;返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="keyword">new</span> String(<span class="string">&quot;asdfzxc&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span>char ch = str.charAt(<span class="number">4</span>);//ch = z</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提取子串<br>用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:<br>1)public String substring(int beginIndex)&#x2F;&#x2F;该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。<br>2)public String substring(int beginIndex, int endIndex)&#x2F;&#x2F;该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str1 = <span class="keyword">new</span> String(<span class="string">&quot;asdfzxc&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span>String str2 = str1.substring(<span class="number">2</span>);//str2 = <span class="string">&quot;dfzxc&quot;</span></span><br><span class="line"><span class="symbol">3 </span>String str3 = str1.substring(<span class="number">2</span>,<span class="number">5</span>);//str3 = <span class="string">&quot;dfz&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>字符串比较<br>1)public int compareTo(String anotherString)&#x2F;&#x2F;该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。<br>2)public int compareToIgnore(String anotherString)&#x2F;&#x2F;与compareTo方法相似，但忽略大小写。<br>3)public boolean equals(Object anotherObject)&#x2F;&#x2F;比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<br>4)public boolean equalsIgnoreCase(String anotherString)&#x2F;&#x2F;与equals方法相似，但忽略大小写。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span>String str2 = <span class="keyword">new</span> String(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"><span class="symbol">3 </span><span class="keyword">int</span> a = str1.compareTo(str2);//a&gt;<span class="number">0</span></span><br><span class="line"><span class="symbol">4 </span><span class="keyword">int</span> b = str1.compareTo(str2);//b=<span class="number">0</span></span><br><span class="line"><span class="symbol">5 </span>boolean c = str1.equals(str2);//c=false</span><br><span class="line"><span class="symbol">6 </span>boolean d = str1.equalsIgnoreCase(str2);//d=true</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>字符串连接<br>public String concat(String str)&#x2F;&#x2F;将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot;aa&quot;</span>.concat(<span class="string">&quot;bb&quot;</span>).concat(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span>相当于String str = <span class="string">&quot;aa&quot;</span>+<span class="string">&quot;bb&quot;</span>+<span class="string">&quot;cc&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>字符串中单个字符查找<br>1)public int indexOf(int ch&#x2F;String str)&#x2F;&#x2F;用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。<br>2)public int indexOf(int ch&#x2F;String str, int fromIndex)&#x2F;&#x2F;改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。<br>3)public int lastIndexOf(int ch&#x2F;String str)&#x2F;&#x2F;该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。<br>4)public int lastIndexOf(int ch&#x2F;String str, int fromIndex)&#x2F;&#x2F;该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot;I am a good student&quot;</span>;</span><br><span class="line"><span class="symbol">2 </span><span class="keyword">int</span> a = str.indexOf(<span class="comment">&#x27;a&#x27;);//a = 2</span></span><br><span class="line"><span class="symbol">3 </span><span class="keyword">int</span> b = str.indexOf(<span class="string">&quot;good&quot;</span>);//b = <span class="number">7</span></span><br><span class="line"><span class="symbol">4 </span><span class="keyword">int</span> c = str.indexOf(<span class="string">&quot;w&quot;</span>,<span class="number">2</span>);//c = -<span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span><span class="keyword">int</span> d = str.lastIndexOf(<span class="string">&quot;a&quot;</span>);//d = <span class="number">5</span></span><br><span class="line"><span class="symbol">6 </span><span class="keyword">int</span> e = str.lastIndexOf(<span class="string">&quot;a&quot;</span>,<span class="number">3</span>);//e = <span class="number">2</span></span><br></pre></td></tr></table></figure>



<ol start="7">
<li>字符串中字符的大小写转换<br>1)public String toLowerCase()&#x2F;&#x2F;返回将当前字符串中所有字符转换成小写后的新串<br>2)public String toUpperCase()&#x2F;&#x2F;返回将当前字符串中所有字符转换成大写后的新串</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="keyword">new</span> String(<span class="string">&quot;asDF&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span>String str1 = str.toLowerCase();//str1 = <span class="string">&quot;asdf&quot;</span></span><br><span class="line"><span class="symbol">3 </span>String str2 = str.toUpperCase();//str2 = <span class="string">&quot;ASDF&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>字符串中字符的替换<br>1)public String replace(char oldChar, char newChar)&#x2F;&#x2F;用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。<br>2)public String replaceFirst(String regex, String replacement)&#x2F;&#x2F;该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。<br>3)public String replaceAll(String regex, String replacement)&#x2F;&#x2F;该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot;asdzxcasd&quot;</span>;</span><br><span class="line"><span class="symbol">2 </span>String str1 = str.replace(<span class="comment">&#x27;a&#x27;,&#x27;g&#x27;);//str1 = &quot;gsdzxcgsd&quot;</span></span><br><span class="line"><span class="symbol">3 </span>String str2 = str.replace(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;fgh&quot;</span>);//str2 = <span class="string">&quot;fghzxcfgh&quot;</span></span><br><span class="line"><span class="symbol">4 </span>String str3 = str.replaceFirst(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;fgh&quot;</span>);//str3 = <span class="string">&quot;fghzxcasd&quot;</span></span><br><span class="line"><span class="symbol">5 </span>String str4 = str.replaceAll(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;fgh&quot;</span>);//str4 = <span class="string">&quot;fghzxcfgh&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>其他类方法<br>1)String trim()&#x2F;&#x2F;截去字符串两端的空格，但对于中间的空格不处理。</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot; a sd &quot;</span>;</span><br><span class="line"><span class="symbol">2 </span>String str1 = str.trim();</span><br><span class="line"><span class="symbol">3 </span><span class="keyword">int</span> a = str.length();//a = <span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="keyword">int</span> b = str1.length();//b = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>2)boolean statWith(String prefix)或boolean endWith(String suffix)&#x2F;&#x2F;用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot;asdfgh&quot;</span>;</span><br><span class="line"><span class="symbol">2 </span>boolean a = str.statWith(<span class="string">&quot;as&quot;</span>);//a = true</span><br><span class="line"><span class="symbol">3 </span>boolean b = str.endWith(<span class="string">&quot;gh&quot;</span>);//b = true</span><br></pre></td></tr></table></figure>

<p>3)regionMatches(boolean b, int firstStart, String other, int otherStart, int length)&#x2F;&#x2F;从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。<br>4)contains(String str)&#x2F;&#x2F;判断参数s是否被包含在字符串中，并返回一个布尔类型的值。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot;student&quot;</span>;</span><br><span class="line"><span class="symbol">2 </span>str.contains(<span class="string">&quot;stu&quot;</span>);//true</span><br><span class="line"><span class="symbol">3 </span>str.contains(<span class="string">&quot;ok&quot;</span>);//false</span><br></pre></td></tr></table></figure>

<p>5)String[] split(String str)&#x2F;&#x2F;将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String str = <span class="string">&quot;asd!qwe|zxc#&quot;</span>;</span><br><span class="line"><span class="symbol">2 </span>String[] str1 = str.split(<span class="string">&quot;!|#&quot;</span>);//str1[<span class="number">0</span>] = <span class="string">&quot;asd&quot;</span>;str1[<span class="number">1</span>] = <span class="string">&quot;qwe&quot;</span>;str1[<span class="number">2</span>] = <span class="string">&quot;zxc&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h2><ol>
<li>字符串转换为基本类型<br>java.lang包中有Byte. Short、Integer、Float、Double类的调用方法：<br>1)public static byte parseByte(String s)<br>2)public static short parseShort(String s)<br>3)public static short parseInt(String s)<br>4)public static long parseLong(String s)<br>5)public static float parseFloat(String s)<br>6)public static double parseDouble(String s)<br>例如：</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="keyword">int</span> n = Integer.parseInt(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="symbol">2 </span>float f = Float.parseFloat(<span class="string">&quot;12.34&quot;</span>);</span><br><span class="line"><span class="symbol">3 </span>double d = Double.parseDouble(<span class="string">&quot;1.124&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>基本类型转换为字符串类型<br>String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。<br>1)static String valueOf(char data[])<br>2)static String valueOf(char data[], int offset, int count)<br>3)static String valueOf(boolean b)<br>4)static String valueOf(char c)<br>5)static String valueOf(int i)<br>6)static String valueOf(long l)<br>7)static String valueOf(float f)<br>8)static String valueOf(double d)<br>例如：</li>
</ol>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>String s1 = String.valueOf(<span class="number">12</span>);</span><br><span class="line"><span class="symbol">2 </span>String s1 = String.valueOf(<span class="number">12.34</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进制转换<br>使用Long类中的方法得到整数之间的各种进制转换的方法：<br>Long.toBinaryString(long l)<br>Long.toOctalString(long l)<br>Long.toHexString(long l)<br>Long.toString(long l, int p)&#x2F;&#x2F;p作为任意进制</li>
</ol>
<h1 id="Java类——Math类"><a href="#Java类——Math类" class="headerlink" title="Java类——Math类"></a>Java类——Math类</h1><h2 id="java-math-Math类常用的常量和方法"><a href="#java-math-Math类常用的常量和方法" class="headerlink" title="java.math.Math类常用的常量和方法"></a>java.math.Math类常用的常量和方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.PI <span class="comment">//记录的圆周率</span></span><br><span class="line">Math.E<span class="comment">//记录e的常量</span></span><br><span class="line">Math.abs <span class="comment">//求绝对值</span></span><br><span class="line">Math.sin <span class="comment">//正弦函数 Math.asin 反正弦函数</span></span><br><span class="line">Math.cos <span class="comment">//余弦函数 Math.acos 反余弦函数</span></span><br><span class="line">Math.tan <span class="comment">//正切函数 Math.atan 反正切函数&amp;amp;nbsp;Math.atan2 商的反正切函数</span></span><br><span class="line">Math.toDegrees <span class="comment">//弧度转化为角度 Math.toRadians 角度转化为弧度</span></span><br><span class="line">Math.ceil <span class="comment">//得到不小于某数的最大整数</span></span><br><span class="line">Math.floor <span class="comment">//得到不大于某数的最大整数</span></span><br><span class="line">例如：Math.floor(<span class="number">12.7</span>) =<span class="number">12.0</span></span><br><span class="line">ceil()<span class="comment">//是天花板，即向上取整。floor是地板，向下取整。round是四舍五入。</span></span><br><span class="line">Math.IEEEremainder <span class="comment">//求余</span></span><br><span class="line">Math.max <span class="comment">//求两数中最大</span></span><br><span class="line">Math.min <span class="comment">//求两数中最小</span></span><br><span class="line">Math.sqrt <span class="comment">//求开方</span></span><br><span class="line">Math.pow <span class="comment">//求某数的任意次方, 抛出ArithmeticException处理溢出异常</span></span><br><span class="line">Math.sqrt(x)：<span class="comment">//平方根</span></span><br><span class="line">Math.pow(x,y)：<span class="comment">//x的y次方</span></span><br><span class="line">Math.exp <span class="comment">//求e的任意次方</span></span><br><span class="line">Math.log10 <span class="comment">//以10为底的对数</span></span><br><span class="line">Math.log <span class="comment">//自然对数</span></span><br><span class="line">Math.rint <span class="comment">//求距离某数最近的整数（可能比某数大，也可能比它小）</span></span><br><span class="line">Math.round <span class="comment">//同上，返回int型或者long型（上一个函数返回double型）</span></span><br><span class="line">Math.random <span class="comment">//返回0，1之间的一个随机数&lt;/p&gt;</span></span><br><span class="line">java.math.BigInteger(大整数)：</span><br><span class="line">BigInteger bi1=<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890123456890&quot;</span>);</span><br><span class="line">BigInteger bi2=BigInteger.valueOf(<span class="number">123L</span>);</span><br><span class="line">bi1=bi1.add(bi2);<span class="comment">//b1+b2</span></span><br><span class="line">bi1=bi1.multiply(bi2);<span class="comment">//b1*b</span></span><br><span class="line">bi1=bi1.subtract(bi2);<span class="comment">//b1-b2</span></span><br><span class="line">bi1=bi1.divide(bi2);<span class="comment">// b1/b2</span></span><br><span class="line">java.math.BigDecimal(大浮点数):</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.1415926&quot;</span>);</span><br><span class="line">bd = bd.setScale(<span class="number">2</span>,BigDecimal.ROUND_DOWN);<span class="comment">//取3.1415926小数点后面二位</span></span><br></pre></td></tr></table></figure>

<h2 id="Java的Math类封装了很多与数学有关的属性和方法，大致如下："><a href="#Java的Math类封装了很多与数学有关的属性和方法，大致如下：" class="headerlink" title="Java的Math类封装了很多与数学有关的属性和方法，大致如下："></a>Java的Math类封装了很多与数学有关的属性和方法，大致如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Math.E);<span class="comment">//比任何其他值都更接近 e（即自然对数的底数）的 double 值。</span></span><br><span class="line">		System.out.println(Math.PI);<span class="comment">//比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1.abs绝对值函数</span></span><br><span class="line"><span class="comment">		 * 对各种数据类型求绝对值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.abs(-<span class="number">10</span>));<span class="comment">//输出10</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 2.三角函数与反三角函数</span></span><br><span class="line"><span class="comment">		 * cos求余弦</span></span><br><span class="line"><span class="comment">		 * sin求正弦</span></span><br><span class="line"><span class="comment">		 * tan求正切</span></span><br><span class="line"><span class="comment">		 * acos求反余弦</span></span><br><span class="line"><span class="comment">		 * asin求反正弦</span></span><br><span class="line"><span class="comment">		 * atan求反正切</span></span><br><span class="line"><span class="comment">		 * atan2(y,x)求向量(x,y)与x轴夹角</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.acos(-<span class="number">1.0</span>));<span class="comment">//输出圆周率3.14...</span></span><br><span class="line">		System.out.println(Math.atan2(<span class="number">1.0</span>, <span class="number">1.0</span>));<span class="comment">//输出 π/4 的小数值</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 3.开根号</span></span><br><span class="line"><span class="comment">		 * cbrt(x)开立方</span></span><br><span class="line"><span class="comment">		 * sqrt(x)开平方</span></span><br><span class="line"><span class="comment">		 * hypot(x,y)求sqrt(x*x+y*y)在求两点间距离时有用sqrt((x1-x2)^2+(y1-y2)^2)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.sqrt(<span class="number">4.0</span>));<span class="comment">//输出2.0</span></span><br><span class="line">		System.out.println(Math.cbrt(<span class="number">8.0</span>));<span class="comment">//输出2.0</span></span><br><span class="line">		System.out.println(Math.hypot(<span class="number">3.0</span>, <span class="number">4.0</span>));<span class="comment">//输出5.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 4.最值</span></span><br><span class="line"><span class="comment">		 * max(a,b)求最大值</span></span><br><span class="line"><span class="comment">		 * min(a,b)求最小值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.max(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//输出2</span></span><br><span class="line">		System.out.println(Math.min(<span class="number">1.9</span>, -<span class="number">0.2</span>));<span class="comment">//输出-0.2</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 5.对数</span></span><br><span class="line"><span class="comment">		 * log(a) a的自然对数(底数是e)</span></span><br><span class="line"><span class="comment">		 * log10(a) a 的底数为10的对数</span></span><br><span class="line"><span class="comment">		 * log1p(a) a+1的自然对数</span></span><br><span class="line"><span class="comment">		 * 值得注意的是，前面其他函数都有重载，对数运算的函数只能传double型数据并返回double型数据</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.log(Math.E));<span class="comment">//输出1.0</span></span><br><span class="line">		System.out.println(Math.log10(<span class="number">10</span>));<span class="comment">//输出1.0</span></span><br><span class="line">		System.out.println(Math.log1p(Math.E-<span class="number">1.0</span>));<span class="comment">//输出1.0</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 6.幂</span></span><br><span class="line"><span class="comment">		 * exp(x) 返回e^x的值</span></span><br><span class="line"><span class="comment">		 * expm1(x) 返回e^x - 1的值</span></span><br><span class="line"><span class="comment">		 * pow(x,y) 返回x^y的值</span></span><br><span class="line"><span class="comment">		 * 这里可用的数据类型也只有double型</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.exp(<span class="number">2</span>));<span class="comment">//输出E^2的值</span></span><br><span class="line">		System.out.println(Math.pow(<span class="number">2.0</span>, <span class="number">3.0</span>));<span class="comment">//输出8.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 7.随机数</span></span><br><span class="line"><span class="comment">		 * random()返回[0.0,1.0)之间的double值</span></span><br><span class="line"><span class="comment">		 * 这个产生的随机数其实可以通过*x控制</span></span><br><span class="line"><span class="comment">		 * 比如(int)(random*100)后可以得到[0,100)之间的整数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println((<span class="type">int</span>)(Math.random()*<span class="number">100</span>));<span class="comment">//输出[0,100)间的随机数</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 8.转换</span></span><br><span class="line"><span class="comment">		 * toDegrees(a) 弧度换角度</span></span><br><span class="line"><span class="comment">		 * toRadians(a) 角度换弧度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(Math.toDegrees(Math.PI));<span class="comment">//输出180.0</span></span><br><span class="line">		System.out.println(Math.toRadians(<span class="number">180</span>));<span class="comment">//输出 π 的值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 9.其他</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//copySign(x,y) 返回 用y的符号取代x的符号后新的x值</span></span><br><span class="line">		System.out.println(Math.copySign(-<span class="number">1.0</span>, <span class="number">2.0</span>));<span class="comment">//输出1.0</span></span><br><span class="line">		System.out.println(Math.copySign(<span class="number">2.0</span>, -<span class="number">1.0</span>));<span class="comment">//输出-2.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//ceil(a) 返回大于a的第一个整数所对应的浮点数(值是整的，类型是浮点型)</span></span><br><span class="line">		<span class="comment">//可以通过强制转换将类型换成整型</span></span><br><span class="line">		System.out.println(Math.ceil(<span class="number">1.3443</span>));<span class="comment">//输出2.0</span></span><br><span class="line">		System.out.println((<span class="type">int</span>)Math.ceil(<span class="number">1.3443</span>));<span class="comment">//输出2</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//floor(a) 返回小于a的第一个整数所对应的浮点数(值是整的，类型是浮点型)</span></span><br><span class="line">		System.out.println(Math.floor(<span class="number">1.3443</span>));<span class="comment">//输出1.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//rint(a) 返回最接近a的整数的double值</span></span><br><span class="line">		System.out.println(Math.rint(<span class="number">1.2</span>));<span class="comment">//输出1.0</span></span><br><span class="line">		System.out.println(Math.rint(<span class="number">1.8</span>));<span class="comment">//输出2.0</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//nextAfter(a,b) 返回(a,b)或(b,a)间与a相邻的浮点数 b可以比a小</span></span><br><span class="line">		System.out.println(Math.nextAfter(<span class="number">1.2</span>, <span class="number">2.7</span>));<span class="comment">//输出1.2000000000000002</span></span><br><span class="line">		System.out.println(Math.nextAfter(<span class="number">1.2</span>, -<span class="number">1</span>));<span class="comment">//输出1.1999999999999997	</span></span><br><span class="line">		<span class="comment">//所以这里的b是控制条件</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//nextUp(a) 返回比a大一点点的浮点数</span></span><br><span class="line">		System.out.println(Math.nextUp(<span class="number">1.2</span>));<span class="comment">//输出1.2000000000000002</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//nextDown(a) 返回比a小一点点的浮点数</span></span><br><span class="line">		System.out.println(Math.nextDown(<span class="number">1.2</span>));<span class="comment">//输出1.1999999999999997	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，当我尝试这样使用数学类的时候是错误的：</p>
 <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span> m = <span class="keyword">new</span> <span class="built_in">Math</span>();m.sqrt(<span class="number">4.0</span>);  </span><br></pre></td></tr></table></figure>

<p>为什么呢？</p>
<p>查了下Math的源码，惊呆了！它的构造方法居然是这样写的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Math</span>()</span> &#123;&#125;  </span><br></pre></td></tr></table></figure>

<p>构造方法写成私有的</p>
<p>所以根本就不能创建对象。</p>
<h1 id="Java中Date各种相关用法"><a href="#Java中Date各种相关用法" class="headerlink" title="Java中Date各种相关用法"></a>Java中Date各种相关用法</h1><h2 id="计算某一月份的最大天数"><a href="#计算某一月份的最大天数" class="headerlink" title="计算某一月份的最大天数"></a>计算某一月份的最大天数</h2><p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar time=Calendar.getInstance(); time.clear(); time.set(Calendar.YEAR,year); time.set(Calendar.MONTH,i-<span class="number">1</span>);<span class="comment">//注意,Calendar对象默认一月为0 int day=time.getActualMaximum(Calendar.DAY_OF_MONTH);//本月份的天数 </span></span><br></pre></td></tr></table></figure>

<p>注：在使用set方法之前，必须先clear一下，否则很多信息会继承自系统当前时间</p>
<h2 id="Calendar和Date的转化"><a href="#Calendar和Date的转化" class="headerlink" title="Calendar和Date的转化"></a>Calendar和Date的转化</h2><p>(1) Calendar转化为Date</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal=Calendar.getInstance(); Date date=cal.getTime(); </span><br></pre></td></tr></table></figure>

<p>(2) Date转化为Calendar</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date=<span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line">Calendar cal=Calendar.getInstance(); </span><br><span class="line">cal.setTime(date); </span><br></pre></td></tr></table></figure>

<h2 id="格式化输出日期时间"><a href="#格式化输出日期时间" class="headerlink" title="格式化输出日期时间"></a>格式化输出日期时间</h2><p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date=<span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line">SimpleDateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>); System.out.println(df.format(date)); </span><br></pre></td></tr></table></figure>

<h2 id="计算一年中的第几星期"><a href="#计算一年中的第几星期" class="headerlink" title="计算一年中的第几星期"></a>计算一年中的第几星期</h2><p>(1)计算某一天是一年中的第几星期</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal=Calendar.getInstance(); </span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2006</span>); </span><br><span class="line">cal.set(Calendar.MONTH, <span class="number">8</span>); </span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>); </span><br><span class="line"><span class="type">int</span> weekno=cal.get(Calendar.WEEK_OF_YEAR); </span><br></pre></td></tr></table></figure>

<p>(2)计算一年中的第几星期是几号</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>); </span><br><span class="line">Calendar cal=Calendar.getInstance(); </span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2006</span>); </span><br><span class="line">cal.set(Calendar.WEEK_OF_YEAR, <span class="number">1</span>); </span><br><span class="line">cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); </span><br><span class="line">System.out.println(df.format(cal.getTime())); </span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2006</span>-<span class="number">01</span>-<span class="number">02</span></span><br></pre></td></tr></table></figure>

<h2 id="add-和roll-的用法"><a href="#add-和roll-的用法" class="headerlink" title="add()和roll()的用法"></a>add()和roll()的用法</h2><p>(1)add()方法</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>); </span><br><span class="line">Calendar cal=Calendar.getInstance(); </span><br><span class="line">cal.set(Calendar.YEAR, <span class="number">2006</span>); </span><br><span class="line">cal.set(Calendar.MONTH, <span class="number">8</span>); </span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>); </span><br><span class="line">cal.add(Calendar.DATE, -<span class="number">4</span>); </span><br><span class="line">Date date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); </span><br><span class="line">cal.add(Calendar.DATE, <span class="number">4</span>); </span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); </span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2006</span>-<span class="number">08</span>-<span class="number">30</span></span><br><span class="line"><span class="attribute">2006</span>-<span class="number">09</span>-<span class="number">03</span></span><br></pre></td></tr></table></figure>

<p>(2)roll方法</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cal.set(Calendar.YEAR, <span class="number">2006</span>); </span><br><span class="line">cal.set(Calendar.MONTH, <span class="number">8</span>); </span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>); </span><br><span class="line">cal.roll(Calendar.DATE, -<span class="number">4</span>); </span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); </span><br><span class="line">cal.roll(Calendar.DATE, <span class="number">4</span>); </span><br><span class="line">date=cal.getTime(); </span><br><span class="line">System.out.println(df.format(date)); </span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2006</span>-<span class="number">09</span>-<span class="number">29</span></span><br><span class="line"><span class="attribute">2006</span>-<span class="number">09</span>-<span class="number">03</span></span><br></pre></td></tr></table></figure>

<p>可见，roll()方法在本月内循环，一般使用add()方法；</p>
<h2 id="计算两个任意时间中间的间隔天数"><a href="#计算两个任意时间中间的间隔天数" class="headerlink" title="计算两个任意时间中间的间隔天数"></a>计算两个任意时间中间的间隔天数</h2><p>(1)传进Calendar对象</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ *<span class="comment">//计算两个时间之间相隔天数 </span></span><br><span class="line">* <span class="meta">@param</span> startday 开始时间 </span><br><span class="line">* <span class="meta">@param</span> endday 结束时间 </span><br><span class="line">* <span class="meta">@return</span> </span><br><span class="line">*/ </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIntervalDays</span><span class="params">(Calendar startday,Calendar endday)</span>...&#123; </span><br><span class="line"><span class="comment">//确保startday在endday之前 </span></span><br><span class="line"><span class="keyword">if</span>(startday.after(endday))...&#123; </span><br><span class="line">Calendar cal=startday; </span><br><span class="line">startday=endday; </span><br><span class="line">endday=cal; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//分别得到两个时间的毫秒数 </span></span><br><span class="line"><span class="type">long</span> sl=startday.getTimeInMillis(); </span><br><span class="line"><span class="type">long</span> el=endday.getTimeInMillis(); </span><br><span class="line"><span class="type">long</span> ei=el-sl; </span><br><span class="line"><span class="comment">//根据毫秒数计算间隔天数 </span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)(ei/(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>(2)传进Date对象</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ *<span class="comment">//计算两个时间之间相隔天数 </span></span><br><span class="line">* <span class="meta">@param</span> startday 开始时间 </span><br><span class="line">* <span class="meta">@param</span> endday 结束时间 </span><br><span class="line">* <span class="meta">@return</span> </span><br><span class="line">*/ </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIntervalDays</span><span class="params">(Date startday,Date endday)</span>...&#123; </span><br><span class="line"><span class="comment">//确保startday在endday之前 </span></span><br><span class="line"><span class="keyword">if</span>(startday.after(endday))...&#123; </span><br><span class="line">Date cal=startday; </span><br><span class="line">startday=endday; </span><br><span class="line">endday=cal; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//分别得到两个时间的毫秒数 </span></span><br><span class="line"><span class="type">long</span> sl=startday.getTime(); </span><br><span class="line"><span class="type">long</span> el=endday.getTime(); </span><br><span class="line"><span class="type">long</span> ei=el-sl; </span><br><span class="line"><span class="comment">//根据毫秒数计算间隔天数 </span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)(ei/(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>同理，可以用相同的方法计算出任意两个时间相隔的小时数，分钟数，秒钟数等</p>
<p>注：以上方法是完全按时间计算，有时并不能令人满意，如：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">startday</span><span class="operator">=</span><span class="string">&quot;2006-10-11 20:00:00&quot;</span></span><br><span class="line"><span class="attribute">endday</span><span class="operator">=</span><span class="string">&quot;2006-10-12 8:00:00&quot;</span></span><br></pre></td></tr></table></figure>

<p>计算结果为0，但是我们也许相让计算结果变为1，此时可以用如下方法实现：</p>
<p>在传参之前，先设定endday的时间，如：</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">endday.set(Calendar.HOUR_OF_DAY, <span class="number">23</span>); </span><br><span class="line">endday.set(Calendar.MINUTE, <span class="number">59</span>); </span><br><span class="line">endday.set(Calendar.SECOND, <span class="number">59</span>); </span><br><span class="line">endday.set(Calendar.MILLISECOND, <span class="number">59</span>); </span><br></pre></td></tr></table></figure>

<p>这样再传进去startday,endday，则结果就如我们所愿了。不过，如果嫌以上方法麻烦，可以参考以下方法：</p>
<p>(3)改进精确计算相隔天数的方法</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDaysBetween</span> <span class="params">(Calendar d1, Calendar d2)</span> ...&#123; </span><br><span class="line"><span class="keyword">if</span> (d1.after(d2)) ...&#123; <span class="comment">// swap dates so that d1 is start and d2 is end </span></span><br><span class="line">java.util.<span class="type">Calendar</span> <span class="variable">swap</span> <span class="operator">=</span> d1; </span><br><span class="line">d1 = d2; </span><br><span class="line">d2 = swap; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> d2.get(Calendar.DAY_OF_YEAR) - d1.get(Calendar.DAY_OF_YEAR); </span><br><span class="line"><span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> d2.get(Calendar.YEAR); </span><br><span class="line"><span class="keyword">if</span> (d1.get(Calendar.YEAR) != y2) ...&#123; </span><br><span class="line">d1 = (Calendar) d1.clone(); </span><br><span class="line"><span class="keyword">do</span> ...&#123; </span><br><span class="line">days += d1.getActualMaximum(Calendar.DAY_OF_YEAR);<span class="comment">//得到当年的实际天数 </span></span><br><span class="line">d1.add(Calendar.YEAR, <span class="number">1</span>); </span><br><span class="line">&#125; <span class="keyword">while</span> (d1.get(Calendar.YEAR) != y2); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> days; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h2><p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSystemTime</span><span class="params">()</span>&#123; </span><br><span class="line">Date date=<span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line">SimpleDateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> df.format(date); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//字符串转化成时间类型（字符串可以是任意类型，只要和SimpleDateFormat中的格式一致即可） </span></span><br><span class="line">java.text.<span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.text.SimpleDateFormat(<span class="string">&quot;M/dd/yyyy hh:mm:ss a&quot;</span>,java.util.Locale.US); </span><br><span class="line">java.util.<span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;5/13/2003 10:31:37 AM&quot;</span>); </span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">String mDateTime1=formatter.format(d); </span><br><span class="line"><span class="comment">//当前时间 </span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance(); </span><br><span class="line"><span class="comment">// SimpleDteFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); </span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formatter</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss G E D F w W a E F&quot;</span>); </span><br><span class="line">String mDateTime=formatter.format(cal.getTime()); </span><br><span class="line"><span class="comment">//1年前日期 </span></span><br><span class="line">java.util.Date myDate=<span class="keyword">new</span> <span class="title class_">java</span>.util.Date(); </span><br><span class="line"><span class="type">long</span> myTime=(myDate.getTime()/<span class="number">1000</span>)-<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">365</span>; </span><br><span class="line">myDate.setTime(myTime*<span class="number">1000</span>); </span><br><span class="line">String mDate=formatter.format(myDate); </span><br><span class="line"><span class="comment">//明天日期 </span></span><br><span class="line">myDate=<span class="keyword">new</span> <span class="title class_">java</span>.util.Date(); </span><br><span class="line">myTime=(myDate.getTime()/<span class="number">1000</span>)+<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>; </span><br><span class="line">myDate.setTime(myTime*<span class="number">1000</span>); </span><br><span class="line">mDate=formatter.format(myDate); </span><br><span class="line"><span class="comment">//两个时间之间的天数 </span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">myFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>); </span><br><span class="line">java.util.Date date= myFormatter.parse(<span class="string">&quot;2003-05-1&quot;</span>); </span><br><span class="line">java.util.Date mydate= myFormatter.parse(<span class="string">&quot;1899-12-30&quot;</span>); </span><br><span class="line"><span class="type">long</span> day=(date.getTime()-mydate.getTime())/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>); </span><br><span class="line"><span class="comment">//加半小时 </span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>); </span><br><span class="line">java.util.<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> format.parse(<span class="string">&quot;2002-02-28 23:16:00&quot;</span>); </span><br><span class="line"><span class="type">long</span> Time=(date1.getTime()/<span class="number">1000</span>)+<span class="number">60</span>*<span class="number">30</span>; </span><br><span class="line">date1.setTime(Time*<span class="number">1000</span>); </span><br><span class="line">String mydate1=formatter.format(date1); </span><br><span class="line"><span class="comment">//年月周求日期 </span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formatter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM F E&quot;</span>); </span><br><span class="line">java.util.Date date2= formatter2.parse(<span class="string">&quot;2003-05 5 星期五&quot;</span>); </span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formatter3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>); </span><br><span class="line">String mydate2=formatter3.format(date2); </span><br><span class="line"><span class="comment">//求是星期几 </span></span><br><span class="line">mydate= myFormatter.parse(<span class="string">&quot;2001-1-1&quot;</span>); </span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formatter4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;E&quot;</span>); </span><br><span class="line">String mydate3=formatter4.format(mydate); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在 开发web应用中，针对不同的数据库日期类型，我们需要在我们的程序中对日期类型做各种不同的转换。若对应数据库数据是oracle的Date类型，即只 需要年月日的，可以选择使用java.sql.Date类型，若对应的是MSsqlserver数据库的DateTime类型，即需要年月日时分秒的，选 择java.sql.Timestamp类型</p>
<p>你可以使用dateFormat定义时间日期的格式，转一个字符串即可</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personal.jessica; </span><br><span class="line"><span class="keyword">import</span> java.util.Date; </span><br><span class="line"><span class="keyword">import</span> java.util.Calendar; </span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp; </span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat; </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat; </span><br><span class="line"><span class="keyword">import</span> java.util.Locale; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Datetest</span>&#123; </span><br><span class="line">/ </span><br><span class="line">*method 将字符串类型的日期转换为一个timestamp（时间戳记java.sql.Timestamp） </span><br><span class="line">*<span class="meta">@param</span> dateString 需要转换为timestamp的字符串 </span><br><span class="line">*<span class="meta">@return</span> dataTime timestamp </span><br><span class="line">*/ </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> java.sql.Timestamp <span class="title function_">string2Time</span><span class="params">(String dateString)</span> </span><br><span class="line"><span class="keyword">throws</span> java.text.ParseException &#123; </span><br><span class="line">DateFormat dateFormat; </span><br><span class="line">dateFormat = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd kk:mm:ss.SSS&quot;</span>, Locale.ENGLISH);<span class="comment">//设定格式 </span></span><br><span class="line"><span class="comment">//dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd kk:mm:ss&quot;, Locale.ENGLISH); </span></span><br><span class="line">dateFormat.setLenient(<span class="literal">false</span>); </span><br><span class="line">java.util.<span class="type">Date</span> <span class="variable">timeDate</span> <span class="operator">=</span> dateFormat.parse(dateString);<span class="comment">//util类型 </span></span><br><span class="line">java.sql.<span class="type">Timestamp</span> <span class="variable">dateTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Timestamp(timeDate.getTime());<span class="comment">//Timestamp类型,timeDate.getTime()返回一个long型 </span></span><br><span class="line"><span class="keyword">return</span> dateTime; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="将字符串类型的日期转换为一个Date（java-sql-Date）"><a href="#将字符串类型的日期转换为一个Date（java-sql-Date）" class="headerlink" title="将字符串类型的日期转换为一个Date（java.sql.Date）"></a>将字符串类型的日期转换为一个Date（java.sql.Date）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/  </span><br><span class="line">*method 将字符串类型的日期转换为一个Date（java.sql.Date）  </span><br><span class="line">*<span class="meta">@param</span> dateString 需要转换为Date的字符串  </span><br><span class="line">*<span class="meta">@return</span> dataTime Date  </span><br><span class="line">*/  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> java.sql.Date <span class="title function_">string2Date</span><span class="params">(String dateString)</span>  </span><br><span class="line"><span class="keyword">throws</span> java.lang.Exception &#123;  </span><br><span class="line">DateFormat dateFormat;  </span><br><span class="line">dateFormat = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>, Locale.ENGLISH);  </span><br><span class="line">dateFormat.setLenient(<span class="literal">false</span>);  </span><br><span class="line">java.util.<span class="type">Date</span> <span class="variable">timeDate</span> <span class="operator">=</span> dateFormat.parse(dateString);<span class="comment">//util类型  </span></span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">dateTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(timeDate.getTime());<span class="comment">//sql类型  </span></span><br><span class="line"><span class="keyword">return</span> dateTime;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line"><span class="type">Date</span> <span class="variable">da</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();  </span><br><span class="line"><span class="comment">//注意：这个地方da.getTime()得到的是一个long型的值  </span></span><br><span class="line">System.out.println(da.getTime());  </span><br><span class="line"><span class="comment">//由日期date转换为timestamp  </span></span><br><span class="line"><span class="comment">//第一种方法：使用new Timestamp(long)  </span></span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timestamp</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime());  </span><br><span class="line">System.out.println(t);  </span><br><span class="line"><span class="comment">//第二种方法：使用Timestamp(int year,int month,int date,int hour,int minute,int second,int nano)  </span></span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timestamp</span>(Calendar.getInstance().get(  </span><br><span class="line">Calendar.YEAR) - <span class="number">1900</span>, Calendar.getInstance().get(  </span><br><span class="line">Calendar.MONTH), Calendar.getInstance().get(  </span><br><span class="line">Calendar.DATE), Calendar.getInstance().get(  </span><br><span class="line">Calendar.HOUR), Calendar.getInstance().get(  </span><br><span class="line">Calendar.MINUTE), Calendar.getInstance().get(  </span><br><span class="line">Calendar.SECOND), <span class="number">0</span>);  </span><br><span class="line">System.out.println(tt);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="type">String</span> <span class="variable">sToDate</span> <span class="operator">=</span> <span class="string">&quot;2005-8-18&quot;</span>;<span class="comment">//用于转换成java.sql.Date的字符串  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">sToTimestamp</span> <span class="operator">=</span> <span class="string">&quot;2005-8-18 14:21:12.123&quot;</span>;<span class="comment">//用于转换成java.sql.Timestamp的字符串  </span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> string2Date(sToDate);  </span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">date2</span> <span class="operator">=</span> string2Time(sToTimestamp);  </span><br><span class="line">System.out.println(<span class="string">&quot;Date:&quot;</span>+date1.toString());<span class="comment">//结果显示  </span></span><br><span class="line">System.out.println(<span class="string">&quot;Timestamp:&quot;</span>+date2.toString());<span class="comment">//结果显示  </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Java获取系统时间的年份</p>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getYear</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance(); </span><br><span class="line">ca.setTime(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date()); </span><br><span class="line"><span class="type">String</span> <span class="variable">year</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>+ca.get(Calendar.YEAR); </span><br><span class="line"><span class="keyword">return</span> year; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getYear</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance(); </span><br><span class="line">ca.setTime(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date()); </span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpledate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>); </span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> simpledate.format(ca.getTime()); </span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ca.get(Calendar.YEAR); </span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ca.get(Calendar.MONTH); </span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ca.get(Calendar.DAY_OF_MONTH); </span><br><span class="line">System.out.println(date+<span class="string">&quot;||&quot;</span>+year+<span class="string">&quot;||&quot;</span>+month+<span class="string">&quot;||&quot;</span>+day); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Cyrus
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://onxs.github.io/post/2018021344.html" title="Java成神之路-JavaSE 面向对象和Java常用类（五）">https://onxs.github.io/post/2018021344.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/2018021244.html" rel="prev" title="Java成神之路-jQuery和XML（四）">
                  <i class="fa fa-angle-left"></i> Java成神之路-jQuery和XML（四）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/2018021444.html" rel="next" title="Java成神之路-Java异常、集合、IO流、多线程和反射（六）">
                  Java成神之路-Java异常、集合、IO流、多线程和反射（六） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">NesT</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">930k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">56:22</span>
  </span>
</div>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/bookmark.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/search/local-search.min.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/tags/pdf.min.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/tags/mermaid.min.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/fancybox.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/pace.min.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/math/mathjax.min.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":false,"timeout":6000,"priority":true,"url":"https://onxs.github.io/post/2018021344.html"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/quicklink.min.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"onxs/onxs.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/comments/utterances.min.js"></script>


</body>
</html>
